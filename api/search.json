[{"id":"2633e840e5205e41695ed670d11c82c1","title":"AiLearning-数学基础-笔记","content":"华为iLearning AI数学基础 课程 笔记课程链接AI数学基础\n一. 线性代数\nAI的核心,通过矩阵表示法实现深度学习方法,非结构化数据–&gt;矩阵(Matrix)&amp;向量(Vector)\n\n张量(Tensor):TensorFlow,Pytorch等深度学习框架的重要组成部分,深度学习中很多运算和模型优化基于tensor完成\n\n线性分类器中,矩阵的应用:\n\n\n目的:判断一张图形是猫,车or人(分被计算与三种对象的相似的得分)\n流程:图形处理(图像展开为列向量)–&gt;求解权重矩阵&amp;偏置矩阵 –&gt; 计算y\n公式:$y &#x3D; w*x + b (w:权重矩阵  x:展开得到的行or列向量  b:偏置矩阵  y:结果)$ \n\n空间中一个矩阵–对应–&gt;一个变换,把这样的矩阵称为 变换矩阵\n\n\n\n\n\n\n\n\n\n线性代数&#x3D;研究 空间变换&amp;向量运动 的科学,\n二者都是有线性变换实现的\n而线性代数中设计的问题都是线性变换or线性映射,即满足:\n\n向量的乘法可以对图像或语音数据进行加强  eg. 进行 平移,旋转,缩放\n\n正交矩阵:$$A^TA &#x3D; AA^T &#x3D; I,即 A^T &#x3D; A^{-1}$$\n\n正交矩阵的行向量与类向量之间都是两两正交的单位向量\n\n向量*正交矩阵&lt;&#x3D;&gt;对向量坐旋转,而无 伸缩or空间映射 作用\n\n应用:正交初始化;正交矩阵的求逆过程–&gt;求矩阵转置;矩阵分解\n![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-LzLCz8mN-1637857412802)(华为AI培训营.assets&#x2F;image-20211124182031622.png)]](https://img-blog.csdnimg.cn/deca0ec6679e4883bbc8e75d61a93ed1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAU3RhY2tDaGFu,size_20,color_FFFFFF,t_70,g_se,x_1\n\n\n\n对角矩阵\n\n\n\n求解 和&#x2F;差&#x2F;积&#x2F;方幂 &lt;&#x3D;&gt;主对角线元素的 和&#x2F;差&#x2F;积&#x2F;方幂\n\n求逆\n\n\n应用:由于计算量小,机器学习中常把某些矩阵限制为对角矩阵–&gt;降低计算开销\n\n\n\n行列式:将方阵–映射到–&gt;标量 的一个函数,记作det(A)\n\n行列式&lt;&#x3D;&gt;矩阵有向面积 or 体积 的推广,or \nn维欧几里得空间中,描述了线性百年换对”体积”造成的影响\n\n行列式的值&#x3D;&#x3D;矩阵特征值的乘积\n\n行列式绝对值&#x3D;&gt;衡量矩阵被乘后 空间扩大or缩小倍数\n\n行列式正负&#x3D;&gt;表示空间的定向\n\n应用:求矩阵特征值,求解线性方程\n\n\n\n特征值&amp;特征向量(只有方阵才有) And 矩阵特征分解\n\n变换矩阵A–&gt;Aa,a只发生伸缩变换,无旋转or投影效果–&gt;所有的*a**为特征向量,伸缩比(相似比)为特征值\n\n特征\n\n\n\n分解:方阵A–分解–&gt;特征向量&amp;特征值,是矩阵(方阵)分解最常用的方法\n\n从线性空间的角度看,λ越大–&gt;矩阵在λ对应的α上的方差越大–&gt;信息量越多\n最优化问题中,矩阵特征值越大,对应特征方向上函数值变化越大,即该方向上,方向导数越大\n应用:PCA降维&#x2F;最优化&#x2F;处理模型过拟合正则化\n\n\n矩阵奇异值分解(是不同于特征分解的另一类分解,非方阵也能分解)\n\n奇异值分解定义:\n\n\n图形意义:\n\n将矩阵的旋转 缩放 投影 分离了出来\n\n应用:灰度图像压缩\n\n\n\n\n​     \n二. 概率论&amp;统计学\n研究不确定性问题\n\n泊松分布–泊松噪声–为图像加泊松噪声–&gt;图像增强\n\n贝叶斯公式:\n\n\n\n\n\n\n\n\n\n\n贝叶斯算法\n\n最优化问题\n\n无约束最优化问题\n\n直接法(问题复杂,写不出具体表达式时,迭代计算产生点列,在其中搜索最优点)\n解析法(即间接法,如:梯度下降法,牛顿法,拟牛顿法)\n\n\n有约束最优化问题(先通过拉格朗日乘子 或 KKT条件 转化为无约束问题,再求解)\n\n梯度下降法:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n梯度下降法是求凸函数极值的做法,对于非凸函数,目前尚无有效方法确定其极值,只能把它当作凸函数来进行处理\n\n\n\n\n三. 实验部分:带视频+实验手册,即实验答案我的工作:建立索引,知道了解它能实现什么,能达成什么效果.\n在真正可能会用到时,能及时从索引中得到答案!\n\n线性代数实验\n\n\nimport numpy as np;from … import scipy as sp\n\n基于numpy(Python的)和 scipy数学模块\n\nreshape(矩阵维度变换)\n\nArray.T(矩阵转置)\n\nnp.matmul(A,B) (矩阵相乘)\n\nnp.arrage(6);reshape(3,2) &#x2F;&#x2F;创建3×2矩阵\n\nprint(A*B) &#x2F;&#x2F;亦可实现矩阵相乘\n\nnp.linalg.inv(A) &#x2F;&#x2F;求逆矩阵\n\nnp.linalg.det(A)  &#x2F;&#x2F;求解行列式的值\n\n学习了奇异值分解进行灰度图像压缩\n\n线性方程的求解,只需要一个函数(scipy.linalg.solve)\n\n\n\n概率论实验\n\n\nimport numpy as np;from … import scipy as sp\n\n基于numpy(Python的)和 scipy数学模块\n\n求均值:np.mean(…)  \n\nnp.var(b) ;np.var(A,1);   # 第二个参数为1,表示按行求方差\n\n二项分布的实现效果: 成功次数、概论、采样次数，并作图\n\n图像加噪声：\n\n背景：深度学习中，需要生成一些新的图像来训练分类模型，但新的模型不能发生根本性的改变。如此，就可以加上一些噪声\nLena灰度图直接加高斯or泊松噪声,噪声比例任选\n\n\n\n\n最优化实验\n\n\n最小二乘法 拟合历史数据\n定义多项式(即拟合函数)\n定义残差函数\n\n","slug":"AiLearning-数学基础-笔记","date":"2022-10-06T14:01:17.000Z","categories_index":"","tags_index":"Math Basis","author_index":"Statck"},{"id":"9dc45ca2f4919602ec235d3605ec2698","title":"mindspore_DCGAN_First_Taste","content":"1.背景:\n\n\n\n\n\n\n\n\n\n华为在各大重点大学,都有基于mindspore的深度学习课程,常常会发放代金券供学生们实验并提交作业(我白嫖了NKU的)。一开始我也尝试过colab或者本机PC（windows），但是发现这些环境mindspore环境要么支持地不太好（例如一些mindspore配套的包不能适配），要么就是自己手动安装mindspore过程中，还需要解决一些包冲突问题。总而言之，既然发了代金券，不用白不用。modelarts上实验大体记录：实验代码(华为老师布置的作业)：生成式对抗网络 生成二次元头像\n2.实验场景:\n\n\n\n\n\n\n\n\n\nmodelartsNotebook环境下训练生成式对抗网络 生成二次元头像\nmindspore官网安装指导如下:获取安装命令\n\n\n\n\n\n\n\n\n\n注:不推荐在PC(windows)上安装mindspore进行训练,推荐去 modelartsNotebook环境下训练,这也是本文的教程主要正对针对的场景 \n\n\n\n\n\n\n\n\n\n注:截止2022年4月26日,mindspore对windows环境的支持依旧不太好,仅有windows×86 cpu的少数几个版本可选,而mindspore自研的mindvision包(一个视觉包,很多情况下都是要使用的),仅支持gpu版本,会因此而做无用功\nmodelarts notebook,mindspore1.5版本,DCGAN训练结果:\n\n在colab上也能训练,但是,如果分到了Tesla K80(单核2线程)那么在安装环境后,还需要:设置num_parallel_workers&#x3D;1(不然会报错,原因是示例中代码开了多线程(2个以上))训完结果也是惨不忍睹:\n","slug":"mindspore-DCGAN-First-Taste","date":"2022-10-06T13:59:24.000Z","categories_index":"","tags_index":"mindspore,DCGAN,FirstTaste","author_index":"Statck"},{"id":"372a48f036f8637b5f6e53362512ed58","title":"数据科学基础(MATLAB)-Note","content":"(本地用typora写的md笔记,导入图片得建一个picGo图床,嫌麻烦,所以如有需要带完整图片的笔记,参见:课件,参见:东北大学数据科学基础MATLAB学习PPT.zip)\n@[toc]\n一. 零散知识\nMATLAB用于编程,Typora提纲,Latex再编排(关于排版问题,github上有模板)\n更多信息,吹爆:https://zhuanlan.zhihu.com/p/394139440\nipython是一个python的交互式shell，比默认的python shell好用得多，支持变量自动补全，自动缩进，支持bash shell命令，内置了许多很有用的功能和函数。”i”指interactive,\n\n\nMATLAB运算汇总设计到的运算\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pCfoHbLD-1651042249324)(data:,)]\n\n(要求:理解数学背景 和 算法原理,能利用它解决应用问题)\n\na&#x3D;b’行列转换;a&#x3D;1:5;b&#x3D;1:2:10;生成向量linspace,数值的等间隔;logspace指数等间隔\n\n广播,向量与矩阵相加\n\nabs(),sqart(),exp(),reminder()\n\n.mat文件的生成(内存变量文件)\n\n矩阵:列优先\n\nx &#x3D; 1:5;等价于x&#x3D;linespace(1,5,5)\n\n单元矩阵:用大括号括起来:非单位矩阵\n\nD &#x3D; sub2ind(size(A),[1,2,2,2,],[1,1;3,2])与[i,j] &#x3D; ind2sub([3,3],[1,3,5])\n\n置空矩阵&#x3D;删除元素;\n\nreshape(x,3,4)\n\nB&#x3D; A(:),将A元素堆叠起来,成为一个列向量’’’’’等价于reshape(A,6,1)\n\n右除&#x2F;,\\左除(原 矩阵有乘法,且乘法不具有交换律,有逆运算,与此处除法? )\n\nA^2\n\nabs(‘MATLAB’)和double(‘MATLAB’)\n\n1、.m文件：.m文件是保存一段代码的文件，类似于C语言中的一个函数体；  这也是MATLAB中最常见的文件保存格式之一。\n2、.mat文件：.mat文件是MATLAB的数据存储的标准格式。也就是操作产生的数据的一个集合包，可以把一次处理的结果保存，供下一次使用。\n\n\nMATLAB中两种类型的数据:\n\n数值型数据\n字符型数据(使用上用特殊性)\n\n\n字符串:\n&gt;&gt;xm&#x3D;&#39;I&#39;&#39;m a teacher.&#39;&#x2F;&#x2F;如果有\n&gt;&gt;subch&#x3D;ch(1:5)\nsubch &#x3D;\nI&#39;m a\n\n%取倒序字符串\n&gt;&gt;revch&#x3D;ch(end:-1:1)\nrevch &#x3D;\n.rehcaet a m&#39;I\n\n%小写变大写\n&gt;&gt;k&#x3D;find(ch&gt;&#x3D;&#39;a&#39;&amp;ch&lt;&#x3D;&#39;z&#39;)\nk &#x3D; \n3 5 7 8 9 10 11 12 13 14\n&gt;&gt;ch(k)&#x3D;ch(k)-(&#39;a&#39;-&#39;A&#39;)%&#123;或者用32%&#125;\nch &#x3D;\nI&#39;M A TEACHER.\n\n%统计字符串中共小写字母的个数\nlength(k)\n\n\n\n\n\n\n\n\n\n\n\n练习中明显发现了MATLAB语言更接近自然语言,其内置大量数以千计的函数,相当于让程序员帮我们完成了很多工作,其简洁性是以语言底层事先的冗余性为代价的;且更接近自然语言,决定了它相对运行效率低,有着同python等脚本语言,解释型语言类似的 语言规则随意性,故而其很多操作语句逻辑性不强,隐藏了极其复杂的底层实现;却新手友好!没有指针,引用,内存分配,平台无关\nMATLAB 是一个模型设计仿真工具，验证了模型之后，会再去用其它语言实现，这是一直以来 MATLAB 的工作模式;它缺少良好的软件工程文化,针对没有太多选择,且需要快速上手解决具体工程问题的非CS工科学生来说,是不得已也最完美的选择;但python也极其完美\n在学习C,C++,Java之后,深刻明白了它们在工程领域的优越性!确实,越底层,学习曲线越陡峭,但越强大越可自定义.而MATLAB的便利性,这些偏底层的语言也已经通过 各种软件工程方法(如特定的框架,易于引用的外部方法库和jar包,智能IDE)\n为了弥补这种解释型语言(写一句执行一句,一旦错了,就要全部重敲,还不能保存,且每次执行一个任务时敲入长长的命令序列是很烦人的。)有两种方法可以使MATLAB的力量得到扩展——脚本和函数。这两种方法都用像emacs一样的文本编辑器中编写的.m文件。m文件的好处在于它可以保存命令，还可以轻易地修改命令而无需重新敲入整个命令行。\n\n\nMATLAB中三种注释方法\n%该行被注释,不执行\n\n\n%%\n此部分作为自定义程序块,非常方便阅读\n%%\n\n\n\n%&#123;\n这\n是\n块注释\n%&#125;\n\n\n“&gt;&gt;”代表命令行提示符   后面还有.m文件,一次性运行\n\nsyms可以定义一些符号,用来进行符号运算,如:syms a&#x3D;1&#x2F;2,可以避免把a由1&#x2F;2–&gt;0.5;\n\nsyms是定义符号变量\nsym是将字符或者数字转换为字符\n比如\nsyms x y %就是定了符号变量x y以后x y就可以直接使用了，有他们运算出来的结果也是符号变量\n当然上面的也可以x&#x3D;sym(‘x’),y&#x3D;sym(‘y’)\nsys(‘a+b’)%就是将a+b转化为符号表达式\n\n\n\n\n\n\n\n\n\n理解:syms S;\nS&#x3D;sum(sym(2).^[0:63])\nsyms与sym的选用,以得到S的精确值而非对数表示\n%当然,S&#x3D;sum(sym(2).^[0:63])也可以,因为右边运算的结果也是符号表达,S类型自然也会被MATLAB分配为符号变量.\n%MATLAB真是门不严谨的语言啊,没有逻辑可言,全凭撸起袖子干\n\n\n\n二. 重点:画图&#x2F;MATLAB可视化技术本章在数学建模中的美化,形象描述数据上具有重大作用!\n(上课课件PPT(全面))[http://neucsecg.neu.edu.cn/userfiles/file/2020/1604300417168078858.pdf]\n\nclear;clc;         清空工作区,并清屏\n\n绘制\n\nplot(x,y1,’-b’,x,y2,’-r’);  绘制二维直角坐标    plot(x,y,z)  绘制三维直角坐标\n\n极坐标polar(x,y,’-*’);   极坐标\n\n\n\n\n\n\n\n\n\n\n\n\nmesh,surf绘制立体曲面\n\n\n\n\n\n\n\n\n\nclear;clc;\n[X,Y]&#x3D;meshgrid(-4:0.1:4,-4:0.1:4);Z&#x3D;cos(X).*sin(Y);surf(X,Y,Z)   or mesh(X,Y,Z)\nxlabel(‘x’);ylabel(‘Y’)zlabel(‘T’)\n\n其他必知的操作:\n\n\n\n\n\n\n\n\n\n\n\n在matlab figure界面中,可以找到tool,属性选择器,可以对camera,刻度等属性进行选择,该界面还可以生成代码\n这些属性通过plot的各项属性(property)一样能实现\n\n\nfigure界面参数:\n\n\n线性,描点类型,颜色参数\n\n\n分隔:(当然,属性选择器中分隔属性选择后,生成代码即可)\n\n\nsubplot绘制分隔\n\n\n\n\naxes绘制分隔\n\n\n\n\n\n叠加绘图\n hold on: 开启保持，之后的绘图将叠加显示 \n hold off: 关闭保持，之后的绘图将覆盖显示\n\n点线式基本命令\n\n\n函数绘图:\n输入函数,写明定义域即可,自动对函数变化密集处密集取点,相当智能\nfplot(@(x)sin(1.&#x2F;x),[0 0.1]);\n\n\n\n​     \n\n特殊二维图形:\n\n\n平面化绘图建议:\n\n\n\n\nwordcloud技术:分析文件中各字符出现次数:中英文词频统计（MATLAB）\n\n\n\n\n\n\n\n\n\n\n先学matlab，入门简单，处理直观，程序不复杂，没有python那么多条条框框。单纯从问题描述里说的各种数据处理，matlab的方便之处就无可替代。\n缺点一就是文本处理始终没有python方便。这里指的是纯汉字或者英语那种，文件里都是数字或者excel文件的话读取和输出还是很方便的。\n缺点二是想运行程序必须安装有matlab，动则10G。如果只是在一台电脑上运行，那就没什么问题。\n等到有一定的熟练度以后，可以再学python。python门槛确实高于matlab，毕竟想要创建一个矩阵还要先导入numpy，画个图导入matplotlib，诸如此类等等，新手可能完全不懂，会陷入复杂的细节漩涡。所以才建议matlab学会后再入手，起码有个基础。\npython优点在于用途广泛，免费。matlab能干的事python大部分也能干，无非就是略微复杂点。python能干的matlab也不一定能干，就是文本、文件处理方面。拓展性也更强。但是python的版本问题，以及各种数值类型等的bug确实也让人头疼，不建议纯新手学。\n如果只学一个，那肯定是matlab。\n如果想循序渐进，先matlab，再python是最好的选择。这个过程可以花几年的时间慢慢过渡，毕竟不管matlab还是python只是一个工具，当你的编程能力逐渐应付不了需求的时候，会自然而然学习更好的工具。\n\n20210919,学会了如何应用MATLAB自带工具箱中的退火算法进行求解最小值(最大值) 模仿视频\n\n矩阵范数\n\n\n针对数 组,自定义函数:\n%???????????0\nsp&#x3D;0\n%????mc_pi????pi\nn&#x3D;input(&#39;input:&#39;);\nsp&#x3D;mc_pi(n);\n\n\n%???????sp\ndisp(sp)\n\n%??????????????(??)\nmatrix&#x3D;[0];\nif n&gt;100\n    for x&#x3D;(n-100):5:n\n    z&#x3D;mc_pi(x);\n    cat(1,matrix,z);\n    end\n    disp(matrix);\n    sp1&#x3D;std(matrix);\n    disp(&#39;std&#x3D;&#39;);\n    disp(sp1);\nend\n\n\nfunction p&#x3D;mc_pi(n)   %??n????????p?????pi?\n%????????????pi\ns&#x3D;0;\nfor k&#x3D;1:n\n    x&#x3D;rand(1);\n    y&#x3D;rand(1);\n    if (x^2+y^2)&lt;&#x3D;1\n        s&#x3D;s+1;\n    end\nend\np&#x3D;s&#x2F;n*4;\nend\n\n由于y&#x3D;z&#x3D;mc_pi(x);其值不能为向量,含恨!!!\n%???????????0\nsp&#x3D;0\n%????mc_pi????pi\nn&#x3D;input(&#39;input:&#39;);\nsp&#x3D;mc_pi(n);\n\n\n%???????sp\ndisp(sp)\n\n%??????????????(??)\nmatrix&#x3D;[];\nif n&gt;100\n    for x&#x3D;(n-100):5:n\n    z&#x3D;[mc_pi(x)];\n    cat(2,matrix,z);\n    end\n    disp(matrix);\n    sp1&#x3D;std(matrix);\n    disp(&#39;std&#x3D;&#39;);\n    disp(sp1);\nend\n\n\nfunction p&#x3D;mc_pi(n)   %??n????????p?????pi?\n%????????????pi\ns&#x3D;0;\nfor k&#x3D;1:n\n    x&#x3D;rand(1);\n    y&#x3D;rand(1);\n    if (x^2+y^2)&lt;&#x3D;1\n        s&#x3D;s+1;\n    end\nend\np&#x3D;s&#x2F;n*4;\nend\n\n\npseudoinverse 伪逆—&gt;pinv\ninverse逆—&gt;inv\n\n\n\n\n\n\n\n\n\n\n &gt;&gt; A[4,:]&#x3D;[]\n 错误: 表达式无效。调用函数或对变量进行索引时，请使用圆括号。否 则，请检查不匹配的分隔符。\n WA!\n &gt;&gt; A(4,:)&#x3D;[]\n AC! \n &gt;&gt; A([1 2],:)&#x3D;A([2 1,:])   %换行操作%\n\n左除与右除\n\n\n\n\n\n\n\n\n\n&gt;&gt; A&#x2F;B*B        %A右除B右乘B&#x3D;A%\nans &#x3D;\n12.0000   34.0000   -4.000034.0000    7.0000   87.0000 3.0000   65.0000    7.0000\n&gt;&gt; B*(B\\A)    % B左乘(A左除B)&#x3D;A% \nans &#x3D;\n12.0000   34.0000   -4.000034.0000    7.0000   87.0000 3.0000   65.0000    7.0000\n\n对于.m文件,\nA&#x3D;[1,2,3;4,5,6];\nB&#x3D;[1,2,3;4,5,6]&#39;;\n%有分号时无输出,无分号时有输出\nC&#x3D;A*B   \n\nMATLAB支持\nfunction [x,y]&#x3D; fun(y,x)\nend\n\n但是\nfunction [x,y]&#x3D; fun(x,y)\nx&#x3D;y;\ny&#x3D;x;\nend\n%两个x无法区分\n\n交换两行(列)\n\n\n\n\n\n\n\n\n\n使用\na([n m],:)&#x3D;a([m n],:)\n1\n\n其中m,n是需要交换的两行，列也同理\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-AiX7QaDZ-1651042249329)(C:\\Users\\31219\\Documents\\Typora Markdown\\杂项\\数据分析-MATLAB.assets\\image-20211011204548821.png)]\n(矩阵任意两个元素则不可交换位置,只能利用temp第三方,直接进行元素赋值来达成)\n以及数组A 第k和k+1个元素交换位置:\nA([k,k+1])&#x3D;A([k+1,k]);\n\n.mat文件：.mat文件是matlab的数据存储的标准格式。也就是操作产生的数据的一个集合包，可以把一次处理的结果保存，供下一次使用。与.m(既可以是脚本文件 也可以是函数文件)不同: 也与.mlx(实时代码or实时脚本文件)   \n\nfor的循环体为矩阵时:\ns&#x3D;0;\na&#x3D;[2,3,4;5,6,7;8,9,10];\nfor k&#x3D;a\n    s&#x3D;s+k;\nend\ndisp(s)\n\n运行结果(自己跑)证明是一列运行一次,就和运行向量(1*n矩阵)一样\n\nif的条件为一个完全非0的矩阵时,条件成立\n\n\n三. 数模算法章(Matlab’s optimization tool box,优化工具箱)\n\n\n\n\n\n\n\n\n自带工具箱可直接通过app图形化界面调用\n非自带工具箱非自带工具箱，需另外下载，然后按照一定的步骤导入，导入后一般不能像上面工具箱一样，通过界面操作，一般都通过函数使用。由于工具箱的导入有几个小的细节需要注意，所以在我的其他经验中，关于如何导入工具箱，我也进行了详细的介绍\nMATLAB绘图:\n1. 退火算法\n\n\n\n\n\n\n\n\n算法特点• 与遗传算法、粒子群优化算法和蚁群算法等不同，模拟退火算法不属于群优化算法，不需要初始化种群操作。\n• 收敛速度较慢。因为1）它初始温度一般设定得很高，而终止温度设定得低，这样才符合物体规律，认为物质处于最低能量平衡点；2）它接受恶化解，并不是全程都在收敛的过程中。这一点可以类比GA中的变异，使得它不是持续在收敛的，所以耗时更多一些。\n• 温度管理（起始、终止温度）、退火速度（衰减函数）等对寻优结果均有影响。比如T的衰减速度如果太快，就会导致可能寻找不到全局最优解。\n\nSA算法的Metropolis准则允许接受一定的恶化解，具体来讲，是以一定概率来接受非最优解。举个例子，相当于保留一些“潜力股”，使解空间里有更多的可能性。对比轮盘赌法，从概率论来讲，它是对非最优解给予概率0，即全部抛弃。\n\n\n四.课程进度向量化编程&amp;如何不使用for循环1.求完数:除了本身外所有因数相加和为本身\nm&#x3D;100;\nfor k&#x3D;2:m\n    cout&#x3D;-k;\n    for l&#x3D;1:sqrt(k)\n        if mod(k,l)&#x3D;&#x3D;0\n            cout&#x3D;cout+l+k&#x2F;l;\n        end\n    end\n    if(cout&#x3D;&#x3D;k)\n        disp(&#39;完数是:&#39;);\n        disp(k);\n    end\nend\n\n\n转换为向量化编程,关键在于累加\nsum之累加是针对一个已有的向量而言的,然而这个向量还不存在,需要靠if ,for得到,而非一个已有的向量,如此,不还是要借助for循环吗?\n敲代码寻方案\n\n\n\n\n\n\n\n\n\n不用for的写法:\n\n求pi值\n\nsyms k;\n%因为和式含参数,而非一个向量,所以要用symsum,不能用sum\nsymsum((-1)^(k+1)&#x2F;(2*k-1),1,inf)\n\n可惜由于运算限制,得到了一个超几何函数!只能弃用这种方法\n向量化编程:\nn&#x3D;input(&#39;input:&#39;);\nk&#x3D;1:n;\nsum((-1).^(k+1)&#x2F;(2.*k-1))*4\n\n\n\n\n\n\n判断一个数是否为素数\n\n一般思路:\nm&#x3D;input(&#39;input:&#39;);\n%法一\n~sum(rem(m,2:sqrt(m)))\n%法二\nisempty(rem(m,2:sqrt(m))\n%法三\nall(rem(m,2:sqrt(m))\n\n\n\n\n\n\n如何将数组倒过来\n行向量就用fliplr函数 列向量就用flipud函数\n　用fliplr,如　　x&#x3D;[1 2 3 4 5];　　fliplr(x)　　ans &#x3D;54321\n\n&#96;&#96;&#96;Lab2A:寻找二进制字符串中最长的“1”序列\n%此处代码不可修改s&#x3D;input(‘请输入仅有0和1组成的二进制字符串’,’s’);\n%填写代码计算最长的1序列，即连续的1的长度% 不能使用循环，结果存入ystrs &#x3D; split(s, ‘0’);%cellfun函数能对每一个元胞元素进行相同的操作,取每一个元胞元素的长度,并用max求最大值y&#x3D;max(cellfun(@length, strs));\ndisp(y);  %显示结果y\n\n6. \n\n\nn&#x3D;input(‘请输入矩阵阶n’);A&#x3D;fix(1000*rand(n));%计算对角线上的连续素数个数% 不使用循环，结果存入yB&#x3D;diag(A)’bo&#x3D;[0 isprime(B) 0];    %让起始和最后的元素与中间的操作统一pos&#x3D;find(bo&#x3D;&#x3D;0);jian&#x3D;diff(pos)y&#x3D;max(jian-1);disp(y)\n\n\n\n7. fun系列:\n\n   ### [bsxfun, *arrayfun, cellfun*, spfun, structfun ](https:&#x2F;&#x2F;www.baidu.com&#x2F;link?url&#x3D;6FyVhkSm6MaFNpbvdK8XQcYvr3xeq_3OrtCq82UROwALdLVV2fLC4uJYk_rx5etkiYsINOJkHvBLVeTcOYW1H_&amp;wd&#x3D;&amp;eqid&#x3D;aab2da0000041f55000000036161858a)\n\n   \n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-APHSm0Vz-1651042249337)(C:\\Users\\31219\\Documents\\Typora Markdown\\杂项\\数据分析-MATLAB.assets\\image-20211009211215835.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;260017d798d34da89e9e0629eba90002.png)\n\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pGYsjuVU-1651042249338)(C:\\Users\\31219\\Documents\\Typora Markdown\\杂项\\数据分析-MATLAB.assets\\image-20211009211309006.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;c4548c5bbee744afaff603ff6fcfd3ac.png)\n\n\n8. 向量化编程技巧:\n\n   1. 将向量视为基本单位,对于&#39;. + 运算符&#39;能解决的问题,可以直接解决,这是最简单的一类:输入n个数,输出n个数\n\n  %%\n  for n=1:10\n     n*5\n  end\n  %%\n  \n  \n  n=1:10;\n  n.*5\n  \n   \n\n2.   需要涉及向量间元素的运算,这类问题往往需要借助 MATLAB现成函数来解决,这是较简单的一类:输入n个数,未必输出n个数\n\n  %%\n  s=0;\n  for k=1:10\n     s=1+k;\n  end\n  %%\n  \n  n=1:10;\n  sum(n)\n  \n   \n\n3. 需要对向量单个元素进行判断的问题,这种问题中应用的技巧被称为masking,用矩阵切片代替判断\n\n  %%\n  s=0;\n  for k=1:10\n     if mod(k,2)==0;\n     s=s+k;\n  end\n  %%\n  \n  %利用masking判断\n  n=1:10;\n  n=n(mod(n,2)==0)\n  \n   \n\n4. 需要对矩阵元素进行某种函数运算,且该函数支持输入向量,那直接上就行,这是最简单的情况\n\n  %%\n  judgement=[];\n  for k=1:10\n     judgement=[judgement,isprime(k)];\n  end\n  %%\n     \n  %若该函数支持输入向量\n  \n  judgement=[isprime(1:10)];\n  \n5. 若该函数不支持输入向量(因为该函数的实现环节中有不支持向量的运算),则使用\n\n  %%\n  %如果用strs=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;],那strs将是字符串&#39;123&#39;,而非 字符串组:&#39;1&#39;,&#39;2&#39;,&#39;3&#39;\n  strs=&#123;&#39;1&#39;,&#39;2&#39;,&#39;3&#39;&#125;\n  %cell元胞数组的每个元素都是cell,可以存放不同类型的数据,取cell元胞数组的元素,可以用strs&#123;1,2&#125;\n  for k=1:length(strs)\n     length(strs(k))\n  end\n  %%\n  \n  %利用fun系列函数cellfun来实现该功能\n  strs=&#123;&#39;1&#39;,&#39;2&#39;,&#39;3&#39;&#125;\n  cellfun(@length,strs);\n        \n      &gt; fun系列函数:\n      &gt;\n      &gt; [bsxfun, *arrayfun, cellfun*, spfun, structfun ](https:&#x2F;&#x2F;www.baidu.com&#x2F;link?url&#x3D;6FyVhkSm6MaFNpbvdK8XQcYvr3xeq_3OrtCq82UROwALdLVV2fLC4uJYk_rx5etkiYsINOJkHvBLVeTcOYW1H_&amp;wd&#x3D;&amp;eqid&#x3D;aab2da0000041f55000000036161858a) \n      &gt;\n      &gt; 对自定义函数,如:f&#x3D;@(x,y) x^2+y^2;\n      &gt;\n      &gt; arrayfun(f,n)而不能用arrayfun(@f,n),否则无法识别f \n      &gt;\n      &gt; 对MATLAB现成函数,则带@\n\nlab2A:寻找最长1序列\n\n1. 利用split切割连续的1序列,\n2. 再用cellfun对元胞元素进行求length操作,\n3. 用max求1序列长度最大值\n\n\n\n\n\n元胞数组不能比较数组元素是否相等,但我们可以用strcmp(A, B)!\n\n\n\n\n\n\n\n完整代码:\n\n\nLab2A:寻找二进制字符串中最长的“1”序列\n%此处代码不可修改s&#x3D;input(‘请输入仅有0和1组成的二进制字符串’,’s’);\n%填写代码计算最长的1序列，即连续的1的长度% 不能使用循环，结果存入ystrs &#x3D; split(s, ‘0’);%cellfun函数能对每一个元胞元素进行相同的操作,取每一个元胞元素的长度,并用max求最大值y&#x3D;max(cellfun(@length, strs));\ndisp(y);  %显示结果y\n\n------\n\nlab2B:找到n阶方阵中对角线上的连续素数个数\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-A2ygy7Hz-1651042249340)(http:&#x2F;&#x2F;neucsecg.neu.edu.cn&#x2F;userfiles&#x2F;client&#x2F;image&#x2F;2021&#x2F;1633951565047087249.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;543700b6d4094612aa657a57b7e167db.png)\n\n\n\n\n说明:详见代码:\n\nLab2B:找到n阶方阵中对角线上的连续素数个数\n%此处代码不可修改n&#x3D;input(‘请输入矩阵阶n’);A&#x3D;fix(1000*rand(n));\n%计算对角线上的连续素数个数% 不能使用循环，结果存入y\n%求对角线,并转置B&#x3D;diag(A)’s&#x3D;isprime(B)%将求得的10101…数组转换为字符数组s&#x3D;num2str(s);%将s字符数组中的空格进行替换为空s&#x3D;strrep(s,’ ‘,’’);\n%对字符数组进行分割s&#x3D;split(s,’0’);%cellfun函数能对每一个元胞元素进行相同的操作,取每一个元胞元素的长度,并用max求最大值y&#x3D;max(cellfun(@length, s));\n%此处代码不可修改disp(y);\n\n------\n\nLab2C:判定n是否为完数，并找到小于n的所有完数\n\n运行结果:\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iitNhD1G-1651042249340)(http:&#x2F;&#x2F;neucsecg.neu.edu.cn&#x2F;userfiles&#x2F;client&#x2F;image&#x2F;2021&#x2F;1633951907712062769.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;533d2a351c074309ae6046e8b0c57f8b.png)\n\n\n\n\n代码:(说明见注释)\n\nLab2C:判定n是否为完数，并找到小于n的所有完数\n%此处代码不可修改n&#x3D;input(‘请输入整数n’);\n% 判定n是否为完数% 不能使用循环，结果存入s(保存logical值即可)n1&#x3D;1:n-1;n1&#x3D;n1(mod(n,n1)&#x3D;&#x3D;0);if sum(n1)&#x3D;&#x3D;n    s&#x3D;true;else    s&#x3D;false;end\n% 找到n以下的所有完数% 不能使用循环，结果存入yf&#x3D;@(x)sum(divisors(x));solvePerfectNumber&#x3D;@(x)arrayfun(f,x);%n以下,理解从1到n-1n2&#x3D;1:n-1;y&#x3D;n2(solvePerfectNumber(n2)&#x3D;&#x3D;2*n2);\n%此处代码不可修改disp(s)disp(y)\n\n附加说明:\n\n第一问判断n是否为完数时,也可用sum(divisors(x))直接求,但我采用了masking切片的方法(收qq群大佬启发)\n\n在求0到100所以完数过程中, 由于\n\nf&#x3D;@(x)sum(divisors(x));\n\n不支持直接输入数组进行运算,(由divisors源码得知,divisors函数只支持标量运算)\n\n所以此处使用了arrayfun,以此对数组元素进行操作\n\n![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;fae46d9b816f4d158af9a5fa356d173d.png)\n\n\n\n\n这个求完数的方法,太妙了!divisors难以用在数组上,而这种主动sum(find(rem(k)&#x3D;&#x3D;0))自己找因数,比我强太多,这就是基础啊\n\n他妙在自定义函数f只对单个数进行处理,这样比对多个数进行处理棒多了\n\n\n\n\n\n常规思路\n\nf&#x3D;@(x)sum(find(rem(x,1:x-1)&#x3D;&#x3D;0));   &#x2F;&#x2F;求所有因数的和n&#x3D;1:1000;n&#x3D;n(f(n)&#x3D;&#x3D;n)&#x2F;&#x2F;矩阵切片判断 代替 for循环if判断\n\n但会报错: \n\n&gt; 错误使用 rem\n&gt; 矩阵维度必须一致。\n&gt;\n&gt; 出错 @(x)sum(find(rem(x,1:x-1)&#x3D;&#x3D;0))\n\n因为f的实现决定了它不支持向量(或者叫一阶矩阵)的运算\n\n于是&#x3D;&#x3D;引用arrayfun&#x3D;&#x3D;函数来处理\n\nf&#x3D;@(x)sum(find(rem(x,1:x-1)&#x3D;&#x3D;0));n&#x3D;1:1000;n&#x3D;n(arrayfun(f,n)&#x3D;&#x3D;n)  &#x2F;&#x2F;arrayfun(f,n)代替f(n)\n\nor\n\nf&#x3D;@(x)sum(find(rem(x,1:x-1)&#x3D;&#x3D;0))&#x3D;&#x3D;x;n&#x3D;1:1000;a&#x3D;find(arrayfun(f,n)&#x3D;&#x3D;1)\n\nor\n\nf&#x3D;@(x)sum(find(rem(x,1:x-1)&#x3D;&#x3D;0));n&#x3D;1:1000;n&#x3D;n(arrayfun(f,n)&#x3D;&#x3D;n)\n\n\n\n\n\n-----------------------\n\n## 数据可视化\n\n\n实验1.分区绘图load carsmallsubplot(2,2,1);histogram(MPG,Model_Year)subplot(2,2,3);boxplot(MPG,Model_Year)subplot(1,2,2);scatter(MPG,Model_Year,’k’)选用了carmall的数组,绘制了MPG与Model_Year的关系实验2：绘图标注figure1 &#x3D; figure;axes1 &#x3D; axes(‘Parent’,figure1,…   ‘Position’,[0.126057529610829 0.190058479532164 0.778942470389171 0.734941520467838]);xlim(axes1,[-43.206190624563 44.6398093754371]);ylim(axes1,[-130.488472719394 133.049527280606]);hold(axes1,’on’);x&#x3D;linspace(-30,30);plot(x,x.exp(sin(x)));annotation(figure1,’textarrow’,[0.455160744500846 0.456006768189509],…   [0.645153846153846 0.523076923076923],’String’,{‘y&#x3D;xexp(sin(x))’});\n实验3:surf和mesh绘图surf:[x,y]&#x3D;meshgrid(-0.25:0.01:0.25,-0.25:0.01:0.25);%以0.1为步长建立平面数据网格r1&#x3D;1.&#x2F;sqrt((x-0.3).^2+y.^2);r2&#x3D;1.&#x2F;sqrt((x+0.3).^2+y.^2);V&#x3D;1.&#x2F;(4pi)&#x2F;(8.85410.^-12)210^-10*(2.&#x2F;r1+4.&#x2F;r2);surf(x,y,V)mesh:t &#x3D; linspace(0,2*pi,20);X &#x3D; sin(t);Y &#x3D; cos(t);Z &#x3D; cos(2.*t);surf(X,Y,Z);实验4三维点线图（含视角调整）\n实验4三维点线图（含视角调整）t &#x3D; linspace(0,2*pi,20);h &#x3D; linspace(0,2, 20)’;X &#x3D; sin(t);Y &#x3D; cos(t);Z &#x3D; cos(2.*t);plot3(X,Y,Z);view(-37.5,30);\n实验5:实验动画绘图:t &#x3D; 0:0.005:6;y&#x3D;sin(2pit);plot(t,y)hold onindex &#x3D; 1;scatter(t(index),y(index),’Marker’,’o’,’MarkerEdgeColor’,’blue’);for index&#x3D;2:length(t)   hold on;   plot(t,y,’Color’,’blue’)   pause(0.05);   scatter(t(index-1),y(index-1),’Marker’,’o’,’MarkerEdgeColor’,’white’);   scatter(t(index),y(index),’Marker’,’o’,’MarkerEdgeColor’,’blue’);end\n\n\n\n-------\n\n## 数据探索性分析\n\n- 集中趋势&amp;离中趋势\n- 分布分析&amp;频度分析\n- 频度分析(周期性分析)\n- 对比分析\n- 相对数分析\n- 相对数对比\n- 数据变换(简单函数变换,规范化)\n- 相关性分析(绘制散点图矩阵)\n\n\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RZnjTkTi-1651042249342)(数据分析-MATLAB.assets&#x2F;image-20211105190105803.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;7638808c948f46a0bda763c2f45cc458.png)\n\n\n[m n]&#x3D;size(gt.m1) \n\nmt&#x3D;[ones(m,n) gt.m1; 2.*ones(m,n) gt.m2; 3.*ones(m,n) gt.m3]\n\nhistogram2(mt(:,1),mt(:,2))\n\n&gt; 解释:\n\n\n\nfor i&#x3D;2:1:6\n\ncor &#x3D; corrcoef(data(:,i),data(:,1)); &gt;&gt; corr(i) &#x3D; cor(1,2); &gt;&gt; disp([&#39;corrcoef of active power and data index &#39; num2str(i) ‘ is &#39; num2str(corr(i))]); &gt;&gt; end &gt;&gt;[m,index]&#x3D;max(corr); &gt;&gt; disp([&#39;the max corr is &#39; num2str(index) &#39; &#39; num2str(m)]);\n\nlab4:\n\n1.housing数据导入工作区\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-RTXQ1CzT-1651042249342)(数据分析-MATLAB.assets&#x2F;image-20211106142246487.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;c0fc8399f4df4dd1a24ec45f3a5e1223.png)\n\n\n2.人口相关数据显示\n\ndisp([‘The maximum of population is ‘ num2str(max(housing.population))]);disp([‘The minimum of population is ‘ num2str(min(housing.population))]);disp([‘The mean of population is ‘ num2str(mean(housing.population))]);\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kkJejt33-1651042249343)(数据分析-MATLAB.assets&#x2F;image-20211106084820595.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;085ccb5a7cc146ae96587c709c53dc83.png)\n\n\n3.人口直方图,50柱块\n\nhistogram(housing.population,50)\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-kgyCesLn-1651042249343)(数据分析-MATLAB.assets&#x2F;image-20211106142012167.png)]\n\n4.查看地理位置(使用了地理气泡图)\n\nhistogram(housing.population,50)\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-q3BoLbYI-1651042249344)(数据分析-MATLAB.assets&#x2F;image-20211106085125630.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;21517a6cd6604a268a4815b5c9dfa94e.png)\n\n\n5.查看total_bedrooms属性,将缺失值用中位数替代,并计算平均值\n\ntemp &#x3D; housing.total_bedrooms; %用temp拷贝total_bedroomstemp(isnan(temp(:,1)))&#x3D;[]; %去掉temp中NaN数据md&#x3D;median(temp); %计算去掉无效数据后的中位数housing.total_bedrooms(isnan(housing.total_bedrooms(:,1)))&#x3D;md;  %将total_bedrooms中的无效数据用该中位数替代mean(housing.total_bedrooms) %计算替代缺失值后的平均值\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-HeT8d4kD-1651042249345)(数据分析-MATLAB.assets&#x2F;image-20211106085713306.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;6ad106c22bf2471f9a412fc1c5663c06.png)\n\n\n6..数据集里有9 个属性都是数值类数据，请计算出median_house_value 和其他8 种属性的相关系数，然后根据结果指出和房价最为相关的属性是什么？\n\ndata &#x3D; table2array(housing); %表转换为矩阵,这样进行协方差处理时才不会出错for i&#x3D;1:1:8 %比较除median_house_value外的八个数据与median_house_value的关系cor &#x3D; corrcoef(data(:,i),data(:,9));corr(i) &#x3D; cor(1,2);disp([‘corrcoef of housing property and data index ‘ num2str(i) ‘ is ‘ num2str(corr(i))]);end[m,index]&#x3D;max(corr);disp([‘the max corr is ‘ num2str(index) ‘ ‘ num2str(m)]);\n\n![\\[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-iNOpY5LQ-1651042249346)(数据分析-MATLAB.assets&#x2F;image-20211106142055824.png)\\]](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;cc5b5629fe474bc5a036f4c4b94480c1.png)\n\n\ndata index 8对应的属性是median_income,说明median_income与median_house_value最相关,也符合生活常识\n\n\n\nMOOC作业:\n\n1.对数据集进行离群值检测。\n\n&#96;&#96;&#96;\\\nfor k&#x3D;1:1:3\n    subplot(2,2,k);\n    boxplot(table2array(car(:,k)));\n    \nend\nsubplot(2,2,4)\nboxplot(table2array(car(:,5)));\n\n\n2.鸢尾花数据集处理:\n鸢尾花数据集是Matlab软件中自带的一个经典数据集。数据集中包含不同品种的花的四个形状指标：萼片长度、萼片宽度、花瓣长度、花瓣宽度。在Matlab 中使用load fisheriris命令加载数据集后，编写程序计算如下问题：\n‏\n‏1）按species分离不同类别的样本；\n‏\n‏2）计算各类别中4个指标的均值、方差、标准差、偏度、峰度等；\n‏\n‏3）作出个指标数据直方图并检验该数据是否服从正态分布。\n第(1)(2)问:\n\n已经问过老师,第(1)(2)是一起的,按species分离不同类别的样本 指 运用向量化编程分别处理不同类别样本 :\n\n代码:\n\nfor k&#x3D;1:4\n\n    disp([&#39;setosa类别中第&#39; num2str(k) &#39;个指标的均值、方差、标准差、偏度、峰度 :&#39;]);\n\n    f(meas(1:50,k));\n\n    disp(&#39;         &#39;);\n\nend\n\n\n\nfor k&#x3D;1:4\n\n    disp([&#39;versicolor类别中第&#39; num2str(k) &#39;个指标的均值、方差、标准差、偏度、峰度 :&#39;]);\n\n    f(meas(51:100,k));\n\n    disp(&#39;         &#39;);\n\nend\n\n\n\nfor k&#x3D;1:4\n\n    disp([&#39;virginica类别中第&#39; num2str(k) &#39;个指标的均值、方差、标准差、偏度、峰度 :&#39;]);\n\n    f(meas(101:150,k));\n\n    disp(&#39;         &#39;);\n\nend\n\n\n\n运行结果:\n\nsetosa类别中第1个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 5.006\n\n方差是 0.12425\n\n标准差是 0.35249\n\n偏度是 0.11645\n\n峰度是 2.6542\n\n         \n\nsetosa类别中第2个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 3.428\n\n方差是 0.14369\n\n标准差是 0.37906\n\n偏度是 0.039921\n\n峰度是 3.7442\n\n         \n\nsetosa类别中第3个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 1.462\n\n方差是 0.030159\n\n标准差是 0.17366\n\n偏度是 0.10318\n\n峰度是 3.8046\n\n         \n\nsetosa类别中第4个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 0.246\n\n方差是 0.011106\n\n标准差是 0.10539\n\n偏度是 1.2159\n\n峰度是 4.4343\n\n         \n\nversicolor类别中第1个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 5.936\n\n方差是 0.26643\n\n标准差是 0.51617\n\n偏度是 0.10219\n\n峰度是 2.4012\n\n         \n\nversicolor类别中第2个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 2.77\n\n方差是 0.098469\n\n标准差是 0.3138\n\n偏度是 -0.35187\n\n峰度是 2.5517\n\n         \n\nversicolor类别中第3个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 4.26\n\n方差是 0.22082\n\n标准差是 0.46991\n\n偏度是 -0.58816\n\n峰度是 2.9256\n\n         \n\nversicolor类别中第4个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 1.326\n\n方差是 0.039106\n\n标准差是 0.19775\n\n偏度是 -0.030236\n\n峰度是 2.5122\n\n         \n\nvirginica类别中第1个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 6.588\n\n方差是 0.40434\n\n标准差是 0.63588\n\n偏度是 0.11444\n\n峰度是 2.9121\n\n         \n\nvirginica类别中第2个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 2.974\n\n方差是 0.104\n\n标准差是 0.3225\n\n偏度是 0.35488\n\n峰度是 3.5198\n\n         \n\nvirginica类别中第3个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 5.552\n\n方差是 0.30459\n\n标准差是 0.55189\n\n偏度是 0.53282\n\n峰度是 2.7435\n\n         \n\nvirginica类别中第4个指标的均值、方差、标准差、偏度、峰度 :\n\n均值是 2.026\n\n方差是 0.075433\n\n标准差是 0.27465\n\n偏度是 -0.12556\n\n峰度是 2.3387\n\n\n\n------\n\n第(3)问:(共计4个指标,无需按鸢尾花的种类分类):\n\nsubplot(2,2,1);\nhistogram(meas(:,1))\nsubplot(2,2,2)\nhistogram(meas(:,2))\nsubplot(2,2,3);\nhistogram(meas(:,3))\nsubplot(2,2,4);\nhistogram(meas(:,4))\n\n\n\n\n拟合与回归&#x3D;&#x3D;重点&#x3D;&#x3D;:线性回归的学习(课件也不错)\n\n&#x3D;&#x3D;regression learner APP:首选,&#x3D;&#x3D;\n\n可以选用线性简单回归模型,及精细树,高斯回归等高级回归模型,可解决当前遇到的一切拟合问题,\n得到的拟合模型(可导出查看) 中蕴含了你想要的各系数的信息.\n得到模型后导出代码,可在其基础上继续编程进行数据处理(如调用trainedModel.Residuals属性查看残差,使用find去除残差过大点),完成包括异常点数据去除等系列问题\n如此,构成了一套完整简便的回归分析处理方案\n(优势:相比于直接代码编程,省去了记忆线性回归代码流程 及 各种非线性回归模型拟合函数的麻烦)\n\n\n直接根据课件进行代码编程(毫无疑问,工具箱生成代码相对你的编程要更为复杂,进行的处理更多,考虑的细节也更多;所以为了代码的简洁,交作业时,还是照样用代码直接编程吧,也不难),且这样能得到极为简洁的线性回归模型,如下:\n\n\n\n&#x3D;&#x3D;重点:&#x3D;&#x3D;拟合的学习:\n\ncurvefit APP确实强大,能选择多种曲线进行拟合,但多数模型似乎都是不能生成函数的,只能生成模型(这些模型中包含各种系数),但对于解题而言,这大概也够了!\n但其最多只能处理三元,\n\n对于figure图床,其也能进行基本的拟合功能,直接生成曲线,但遗憾不能导出函数\n\n\n问题:\n\n训练完成后导出trainedModel,但是无法找到其函数知识\n很多使用盲区,是否应该首先去其说明文档查找\n\n\nLab6a:酒精含量回归预测\n（1）请先对数据绘制其血液中酒精含量与酒后时间的散点图\n\n\n \n  （2）选择多项式函数进行广义线性回归分析，并建立人体血液酒精含量与酒后时间的函数关系。(我采用了六次多项式函数来进行拟合,当然次数越高拟合效果越好,但实验多次后发现六次已经能取得较好拟合效果)\n  x&#x3D;Lab6aData.VarName1,y&#x3D;Lab6aData.VarName2;\n\np &#x3D; polyfit(x,y,6);\n%使用 polyval 计算可能未包含在原始数据中的其他点处的多项式\nx2 &#x3D; 0:.1:16;\ny2 &#x3D; polyval(p,x2);\nplot(x,y,&#39;o&#39;,x2,y2)\ngrid on\ns &#x3D; sprintf(&#39;y &#x3D; (%.1f) x^3 + (%.1f) x^2 + (%.1f) x + (%.1f)&#39;,p(1),p(2),p(3),p(4));\ntext(2,400,s)\n\n  \n\nLab6b：销售额回归模型（含异常值）\n\n\n\n\n\n\n\n\n\n问题描述:\n请你帮助公司管理人员根据这些数据找到销售额与其他三个变量之间的关系，以便进行销售额预测，并从中发现是否存在异常点，如果有异常点，请做必要的处理并重新进行回归分析。要求保存各步骤至实验报告，并提交。\n首先导入数据,然后开始依次进行:回归–&gt;诊断–&gt;剔除异常值–&gt;重新回归分析\n%回归\nX &#x3D; [Lab6bData.VarName2,Lab6bData.VarName3,Lab6bData.VarName4];\nmdl &#x3D; fitlm(X, Lab6bData.VarName5)\n\nfigure;\nmdl.plot;\n\n\n%诊断\nRes &#x3D; mdl.Residuals;\nRes_stan &#x3D; Res.Standardized; %标准化残差\nfigure;\nplot(Res_stan, &#39;kx&#39;);\nrefline(0, 1.3);\nrefline(0, -1.3);\n\n\n%剔除异常值\nid &#x3D; find(abs(Res_stan)&gt;1.3);\n\n\n\n\n%重新回归分析\nmdl2 &#x3D; fitlm(X, Lab6bData.VarName5, &#39;Exclude&#39;, id);\nfigure;\nmdl2.plot;\n\n\n\n使用MATLAB自带的fisheriris数据集，编程实现如下要求。\n‎\n（1）去除setosa类别数据，保留virginica和versicolor两类数据。\n‎\n（2）将两类数据，共100个样本拆分成训练集和测试集，拆分比例为8:2，即80个样本用于训练，20个样本用于测试。（提示：不同类别的样本分别拆分）\n‎\n（3）使用训练集数据建立SVM分类器模型，并应用测试集数据进行测试。输出准确率。（注意：答案不唯一，算法流程正确即可）\nload fisheriris\n%去除setosa类别数据\nX &#x3D; meas(51:150,:); % Use all data for fitting\nY &#x3D; species(51:150,:); % Response data\n\n%将两类数据，共100个样本拆分成训练集和测试集，拆分比例为8:2\nTrainX1 &#x3D; X(1:40,:);\nTrainY1 &#x3D; Y(1:40,:);\n\nTestX1 &#x3D; X(41:50,:);\nTestY1 &#x3D; Y(41:50,:);\n\nTrainX2 &#x3D; X(51:90,:);\nTrainY2 &#x3D; Y(51:90,:);\n\nTestX2 &#x3D; X(91:100,:);\nTestY2 &#x3D; Y(91:100,:);\n\ntrainX &#x3D; [TrainX1;TrainX2];\ntestX &#x3D; [TestX1;TestX2];\ntrainY &#x3D; [TrainY1;TrainY2];\ntestY &#x3D; [TestY1;TestY2];\n\n%训练\nsvmmodel &#x3D; fitcsvm(trainX,trainY, &#39;Standardize&#39;, true);\n%预测\nresult &#x3D; predict(svmmodel, testX);\n\n%评估\naccuracy &#x3D; sum(strcmp(testY,result))&#x2F;20\n\n\n\n分类完整流程(划分测试集,训练,计算准确率accuracy):以鸢尾花为例\n知识点\n\nKNN算法(最近邻算法)\n\nSVM(支持向量机,属于逻辑回归):最常用,找到使间隔最大化的平面\n\n\n\n\nlab1. 对数据集进行合理分割，选取KNN方法进行分类模型训练，并通过调整不同K值分析K取值对模型评价指标（具体指标可自行选择）的影响。\n%将数据进行处理,分别得到属性数据 &amp; 标签\nX &#x3D; [Lab5adata.Fe,Lab5adata.Co,Lab5adata.Zn;Lab5adata.Fe1,Lab5adata.Co,Lab5adata.Zn1];\nY &#x3D; [Lab5adata.VarName2;Lab5adata.VarName7];\n[size_r,size_c]&#x3D;size(X);\n\n%合理分隔为测试集和训练集\nTrainX&#x3D; X(1:size_r*0.75,:);\nTrainY&#x3D; Y(1:size_r*0.75,:);\nTestX &#x3D; X(size_r*0.75+1:size_r,:);\nTestY &#x3D; Y(size_r*0.75+1:size_r,:);\n\n\nfor K&#x3D;1:5\n    %训练\n    knnmodel &#x3D; fitcknn(TrainX,TrainY,&#39;NumNeighbors&#39;,K);\n    %预测\n    [predict_trainY] &#x3D; predict(knnmodel,TrainX);\n    [predict_testY] &#x3D; predict(knnmodel,TestX);\n    \n    %计算并打印训练集和测试集准确率\n    compare_train &#x3D; TrainY&#x3D;&#x3D;predict_trainY;\n    accuracy_train &#x3D; sum(compare_train)&#x2F;size(TrainX,1)*100;\n    fprintf(&#39;K值为%d时训练集准确率：%f\\n&#39;,K,accuracy_train);\n    \n    compare_test &#x3D; TestY&#x3D;&#x3D;predict_testY;\n    accuracy_test &#x3D; sum(compare_test)&#x2F;size(TestX,1)*100;\n    fprintf(&#39;K值为%d时测试集准确率：%f\\n\\n&#39;,K,accuracy_test);\nend\n\n\n\n\n运行结果:\n\n(改图是原来错误代码的运行结果,全都是训练集准确率,没有测试集准确率)\n根据运行结果可以初步推测:K较小时,准确率应该会更高\nlab2:给出了60位就诊患者的化验指标，其中1 ~ 30号病例是已经确诊为肾炎病人的化验结果；31~60号是正常健康人的结果。请使用SVM算法建立肾炎患者识别模型，并通过选取交叉验证过程中不同的折数，分析对比在不同折数的情况下对模型评价指标（具体指标可自行选择）的影响。\n\n编写f.m函数,函数功能:输入k(交叉验证折数)和data(进行处理后的表格数据),可以进行svm分类,并输出k折时训练集和测试集平均准确率\n对表格数据进行数据处理后,使用f.m函数,输出5到15折下,训练集准确率\n\nf.m代码:\nfunction f(K,data)\nlable&#x3D;&#123;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;\n        &#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;\n        &#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;&#39;yes&#39;;\n        &#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;\n        &#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;\n        &#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;;&#39;no&#39;&#125;;\n\n[data_r,~] &#x3D; size(data);\n\n%将数据样本随机分割为K部分\nindices &#x3D; crossvalind(&#39;Kfold&#39;, data_r, K);\n\n\naccuracy_train_sum&#x3D;0;\naccuracy_test_sum&#x3D;0;\nfor i &#x3D; 1 : K\n    \n    % 获取第i份测试数据的索引逻辑值\n    \n    test &#x3D; (indices &#x3D;&#x3D; i);\n    \n    % 取反，获取第i份训练数据的索引逻辑值\n    \n    train &#x3D; ~test;\n    \n    %1份测试，其余训练\n    \n    testX &#x3D; data(test,:);\n    testY &#x3D; lable(test,:);\n    \n    trainX &#x3D; data(train,:);\n    trainY &#x3D; lable(train, :);\n    \n    % 拟合\n    svmmodel&#x3D;fitcsvm(trainX,trainY);\n    \n    %SVM预测\n    [predict_trainY] &#x3D; predict(svmmodel,trainX);\n    [predict_testY] &#x3D; predict(svmmodel,testX);\n    \n    % 计算单此预测准确率 并加和\n    compare_train &#x3D; strcmp(trainY,predict_trainY);\n    accuracy_train &#x3D; sum(compare_train)&#x2F;size(trainX,1)*100;\n    accuracy_train_sum&#x3D;accuracy_train_sum+accuracy_train;\n    \n    compare_test &#x3D; strcmp(testY,predict_testY);\n    accuracy_test &#x3D; sum(compare_test)&#x2F;size(testX,1)*100;\n    accuracy_test_sum&#x3D;accuracy_test_sum+accuracy_test;\n    \nend\nfprintf(&#39;%d折时训练集平均准确率：%f\\n&#39;,K,accuracy_train_sum&#x2F;K);\nfprintf(&#39;测试集平均准确率：%f\\n\\n&#39;,accuracy_test_sum&#x2F;K);\n\n\n\n\n调用f.m输出结果:\n%数据预处理\ndata &#x3D; [Lab5bdata.Zn,Lab5bdata.Cu,Lab5bdata.Fe ,Lab5bdata.Ca,Lab5bdata.Mg,Lab5bdata.K,Lab5bdata.Na];\ndata(1,:)&#x3D;[];\n%调用f.m输出结果\nfor k&#x3D;5:15\n    f(k,data);\nend\n\n\n\n\n\n\n运行结果:\n\n聚类\n要求:把握 \n\n三个关键概念\n\n样本间距离 \n变量间的相似系数 \n类间距离\n\n\n谱系聚类\n\n\n\n\n\n\n\n\n\n谱系聚类首先将各样品自成一类，然后把最相似(距离最近或相似系数最大)的样品聚为小类， 再将已聚合的小类按各类之间的相似性(用类间 距离度量)进行再聚合，随着相似性的减弱，最 后将一切子类都聚为一大类，从而得到一个按 相似性大小聚结起来的一个谱系图\n\n\nK均值(K-Means)聚类\n\n\n\n\n\n\n\n\n\n K-Means算法是典型的基于距离的非层次聚类 算法，在最小化误差函数的基础上将数据划分 为预定的类数K，采用距离作为相似性的评价指 标，即认为两个对象的距离越近，其相似度就 越大。 K-Means聚类算法中，一般需要度量样本之间 的距离、样本与簇之间的距离以及簇与簇之间 的距离\n \n\n\n\n课程中的源代码:\n\n\n\n\n\n\n\n\n\n\n谱系聚类:\nz1&#x3D;linkage(d, &#39;single&#39;); %最短距离\nH1&#x3D; dendrogram(z1) %谱系图\nT1&#x3D;cluster(z1,3);\nfigure\nz2&#x3D;linkage(d,&#39;centroid&#39;); %重心距离\nH2&#x3D; dendrogram(z2) %谱系图\nT2&#x3D;cluster(z2,3);\n\n%根据z2(可以在实时脚本界面查看其数据)orT2?是极其容易绘图的,dendrogram(z2) 只是绘图的方法之一\n\n对于谱系聚类,常用指标:1. 𝑅^2统计量  2. 伪F统计量\n1.𝑅^2统计量\n\n\n\n\n\n\n\n\n\n\n&gt;Tm&#x3D;sum(kmax*var(x));\n&gt;bm&#x3D;Tm-pm;\n&gt;R&#x3D;bm.&#x2F;Tm;\n&gt;plot((2:20),R(2:20),&#39;*&#39;); xlabel(&#39;分类数&#39;); ylabel(&#39;R2值&#39;);\n\n2.伪F统计量\n\n\n&gt;F&#x3D;zeros(kmax,1);\n&gt;for kk&#x3D;2:kmax\n&gt;F(kk)&#x3D;bm(kk)&#x2F;pm(kk)*(n-kk)&#x2F;(kk-1);\n&gt;end\n&gt;plot((2:20),F(2:20),&#39;*&#39;) ; xlabel(&#39;分类数&#39;); ylabel(&#39;F值&#39;);\n\n\n\n\n\nK-Means聚类:\n&gt;% 参数初始化\n&gt;k &#x3D; 3; % 聚类的类别\n&gt;iteration &#x3D;500 ; % 聚类最大循环次数\n&gt;distance &#x3D; &#39;sqEuclidean&#39;; % 距离函数\n&gt;%% 数据标准化\n&gt;X &#x3D; zscore(data);\n&gt;scatter3(X(:,1),X(:,2),X(:,3),&#39;k.&#39;)\n&gt;%% 调用kmeans算法\n&gt;opts &#x3D; statset(&#39;MaxIter&#39;,iteration);\n&gt;[IDX,C,~,D] &#x3D; kmeans(X,k,&#39;distance&#39;,distance,&#39;Options&#39;,opts);\n\n&gt;%而根据IDX(可以在实时脚本界面查看其数据)是极容易进行绘图的,下面的Lab7,其绘图代码就是我自己写的!\n&gt;figure;\n&gt;scatter3(X(IDX&#x3D;&#x3D;1,1),X(IDX&#x3D;&#x3D;1,2),X(IDX&#x3D;&#x3D;1,3),&#39;r.&#39;)\n&gt;hold on\n&gt;scatter3(X(IDX&#x3D;&#x3D;2,1),X(IDX&#x3D;&#x3D;2,2),X(IDX&#x3D;&#x3D;2,3),&#39;m.&#39;)\n&gt;scatter3(X(IDX&#x3D;&#x3D;3,1),X(IDX&#x3D;&#x3D;3,2),X(IDX&#x3D;&#x3D;3,3),&#39;c.&#39;)\n&gt;plot3(C(:,1),C(:,2),C(:,3),&#39;ko&#39;,&#39;MarkerSize&#39;,4,&#39;LineWidth&#39;,1.5)\n&gt;legend(&#39;Cluster 1&#39;,&#39;Cluster 2&#39;,&#39;Cluster 3&#39;,&#39;Centroids&#39;,...\n&gt;&#39;Location&#39;,&#39;NW&#39;)\n\n\n\n对于K-means聚类,常用指标:𝐹(𝑇,𝐾)(来源PPT,具体是啥不知道,没查到,反正不是伪F统计量)\n\n\n\n\n\n\n\n\n\n\n&gt;q&#x3D;2:12;\n&gt;for i&#x3D;1:length(q)\n&gt;[IDX,C,sumd,D]&#x3D;kmeans(X,q(i));\n&gt;m&#x3D;mean(X);\n&gt;a(i)&#x3D;sum(dist(C,m&#39;));\n&gt;b(i)&#x3D;(sumd(i)).^0.5;\n&gt;end\n&gt;F&#x3D;abs(a.&#x2F;b-1);\n&gt;plot(q,F,&#39;-*&#39;);\n\n\n\n\nLab7\n\n\n\n\n\n\n\n\n\n\n\n为我国部分省市的城镇居民人均可支配收入来源（单位：元&#x2F;人），利用该表数据，尝试聚类并回答下面的问题。\n\n计算各样品间的欧氏距离、马氏距离和加权平方距离。\n运用谱系聚类法进行聚类，包括确定最优聚类数，选择合适的类间距离，同时做出谱系图。\n运用K-Means聚类法进行聚类，并建立最佳聚类数公式。\n【选做】，在Matlab中还有一种聚类方法称为模糊C均值聚类(fcm)，自行查阅资料，学习该聚类方法的使用，并以步骤3确定的最佳聚类数进行模糊C均值聚类。\n综合分析以上不同的聚类法所得的聚类结果，给出你的对比分析结论。\n\n\n计算各样品间的欧氏距离、马氏距离和加权平方距离。\nx&#x3D; [Lab7Data.VarName2,Lab7Data.VarName3,Lab7Data.VarName4,Lab7Data.VarName5]\n\n% Step1:计算距离\ndistance1 &#x3D;pdist(x,&#39;euclidean&#39;) % 欧氏距离；\ndistance2 &#x3D;pdist(x,&#39;mahalanobis&#39;) % 马氏距离\ndistance3 &#x3D;pdist(x,&#39;seuclidean&#39;) % 方差加权距离\n\n结果:\n\n\n运用谱系聚类法进行聚类，包括确定最优聚类数，选择合适的类间距离，同时做出谱系图。\n\n\n% Step2:谱系聚类，选择合适的类间距离\n\n[n,p]&#x3D;size(x);\nkmax&#x3D;n-1;\npm&#x3D;zeros(kmax,1);\npm(1)&#x3D;1;\n\nd&#x3D;pdist(x);\nz1&#x3D;linkage(d, &#39;single&#39;); %最短距离\nz2&#x3D;linkage(d,&#39;complete&#39;); %最长距离\nz3&#x3D;linkage(d,&#39;average&#39;); %类平均距离\nz4&#x3D;linkage(d,&#39;centroid&#39;); %重心距离\nz5&#x3D;linkage(d,&#39;ward&#39;); %离差平方和距离\nR&#x3D;[cophenet(z1,d),cophenet(z2,d),cophenet(z3,d),cophenet(z4,d),cophenet(z5,d)]\n\n\n所以我们选择平均距离.\n%根据R方统计量,确定最优聚类数\nfor k&#x3D;2:kmax\n    z1&#x3D;linkage(d,&#39;average&#39;);  %按照平均类间距离创建谱系聚类树\n    c&#x3D;cluster(z1,k); %聚类结果\n    for t&#x3D;1:k\n        index_t&#x3D;find(c&#x3D;&#x3D;t);\n        size_t&#x3D;length(index_t);\n        a&#x3D;x(index_t,:);\n        pm(k)&#x3D;sum((size_t-1)*var(a))+pm(k);\n    end\nend\n\n\nTm&#x3D;sum(kmax*var(x));\nbm&#x3D;Tm-pm;\nR&#x3D;bm.&#x2F;Tm;\nplot((2:30),R(2:30),&#39;*&#39;); xlabel(&#39;分类数&#39;); ylabel(&#39;R2值&#39;)\n\nR方统计量结果:\n可以看到,分类数达到5后,统计量增加不再明显,所以可以选择5作为最优聚类数.\nx&#x3D; [Lab7Data.VarName2,Lab7Data.VarName3,Lab7Data.VarName4,Lab7Data.VarName5];\nd&#x3D;pdist(x);\nz1&#x3D;linkage(d,&#39;average&#39;);  %按照平均类间距离创建谱系聚类树\nc&#x3D;cluster(z1,5); %聚类结果\n% 做出聚类数为5时的谱系图\nH1&#x3D; dendrogram(z1); %绘制谱系聚类树(即谱系图)\n\n\n\n运用K-Means聚类法进行聚类，并建立最佳聚类数公式。\n%% 数据标准化\ndata &#x3D; [Lab7Data.VarName2,Lab7Data.VarName3,Lab7Data.VarName4,Lab7Data.VarName5];\nX &#x3D; zscore(data);\n\n%一般我们在2-12之间选择分类数\nq&#x3D;2:12;\nfor i&#x3D;1:length(q)\n    %% 调用kmeans算法\n    [IDX,C,sumd,D]&#x3D;kmeans(X,q(i));\n    m&#x3D;mean(X);\n    a(i)&#x3D;sum(dist(C,m&#39;));\n    b(i)&#x3D;(sumd(i)).^0.5;\nend\nF&#x3D;abs(a.&#x2F;b-1);\n\n%画出伪F统计量随分类数变化图\nplot(q,F,&#39;-*&#39;);\n\n结果图:\n\n\n\n所以我们选择6作为最佳聚类数\n% 参数初始化\nk &#x3D; 6; % 聚类的类别\niteration &#x3D;500 ; % 聚类最大循环次数\ndistance &#x3D; &#39;sqEuclidean&#39;; % 距离函数\n%% 数据标准化\ndata &#x3D; [Lab7Data.VarName2,Lab7Data.VarName3,Lab7Data.VarName4,Lab7Data.VarName5];\nX &#x3D; zscore(data);\nLabel&#x3D;categorical(Lab7Data.VarName1);\n\n%% 调用kmeans算法\nopts &#x3D; statset(&#39;MaxIter&#39;,iteration);\n[IDX,C,~,D] &#x3D; kmeans(X,k,&#39;distance&#39;,distance,&#39;Options&#39;,opts);\n\n%聚类结果可视化\nfigure;\nplot(1,Label(IDX&#x3D;&#x3D;1),&#39;r.&#39;)\nhold on\nplot(2,Label(IDX&#x3D;&#x3D;2),&#39;g.&#39;)\nplot(3,Label(IDX&#x3D;&#x3D;3),&#39;b.&#39;)\nplot(4,Label(IDX&#x3D;&#x3D;4),&#39;y.&#39;)\nplot(5,Label(IDX&#x3D;&#x3D;5),&#39;m.&#39;)\nplot(6,Label(IDX&#x3D;&#x3D;6),&#39;c.&#39;)\n% % plot3(C(:,1),C(:,2),C(:,3),&#39;ko&#39;,&#39;MarkerSize&#39;,4,&#39;LineWidth&#39;,1.5)\n\n\n由于老师给出的数据有4个指标,不像PPT中的只有三个指标,不能利用scatter3画出4维指标的聚类结果,\n\n(1表示聚类1,2表示聚类2…6表示聚类6,相同颜色的点代表同一个省份)\n由图可以看出,青海,陕西,贵州,重庆等西部欠发达省份在聚类一,\n广东,山东等较发达省份在聚类二,\n北京,上海等高度发达省份在聚类三,\n….\n总体而言,分类还是较为符合实际的.\n\n综合分析以上不同的聚类法所得的聚类结果，给出你的对比分析结论。\n\n当聚类数较多时,二者均可取得较好的统计量观测结果\n最佳类别数是导致聚类的有效性的核心.\nCategory ,String ,Cell的转化?呵呵,别做梦了吧!简直要崩溃了!这些方面都完不成,事实无不证明,他们只是在浪费你本就不多的时间!\n\nMOOC单元作业八:\n\n\n\n\n\n\n\n\n\n‌附件为MovieLens提供的电影评分数据集，在数据集中，ratings.csv文件中包含了用户对电影的评分，用户和电影都以各自的ID来表示。假定对影片评分相近作为用户之间的相似度衡量标准，请对数据做必要的预处理构造用户-影片的评分矩阵，并计算用户的相似度。之后根据用户相似度对用户做聚类分析，并对结果做出合理解释。（解释结果可参考数据集中其他数据文件）\n\n\n\n构造用户-影片的评分矩阵\n\n\n\n\n\n\n\n\n\n相当于用户是分类对象,由于影片数过多,两个用户评到同一部影片几率过小,我们取一个用户影片所评价过的所有影片评分平均值作为分类指标\n\n聚类分析:\ndata&#x3D;[ratings.userId,ratings.rating];\n\n%%构造用户-影片的评分矩阵\n\n%初始化评分矩阵\nx &#x3D; zeros(610,1);\n\nfor k&#x3D;1:610\n    %计算每个用户的影片评分平均分,为用户赋值\n    x(k,1)&#x3D;(mean(data(data(:,1)&#x3D;&#x3D;k,2)));\nend\n\n% 参数初始化\nk &#x3D; 3; % 聚类的类别\niteration &#x3D;500 ; % 聚类最大循环次数\ndistance &#x3D; &#39;sqEuclidean&#39;; % 距离函数\n%% 数据标准化\nX &#x3D; zscore(x);\n% scatter(X(:,1),X(:,2),X(:,3),&#39;k.&#39;)\n%% 调用kmeans算法\nopts &#x3D; statset(&#39;MaxIter&#39;,iteration);\n[IDX,C,~,D] &#x3D; kmeans(X,k,&#39;distance&#39;,distance,&#39;Options&#39;,opts);\n\n\n%聚类结果可视化\nfigure;\nUserId &#x3D; 1:610;\nfigure;\nscatter(UserId(IDX&#x3D;&#x3D;1),x(IDX&#x3D;&#x3D;1),&#39;r.&#39;)\nhold on\nscatter(UserId(IDX&#x3D;&#x3D;2),x(IDX&#x3D;&#x3D;2),&#39;m.&#39;)\nscatter(UserId(IDX&#x3D;&#x3D;3),x(IDX&#x3D;&#x3D;3),&#39;c.&#39;)\nlegend(&#39;Cluster 1&#39;,&#39;Cluster 2&#39;,&#39;Cluster 3&#39;,&#39;Centroids&#39;,...\n&#39;Location&#39;,&#39;NW&#39;)\nxlabel(&#39;用户Id&#39;); ylabel(&#39;用户平均电影评分&#39;)\n\n\n\n\n运行结果:\n\n\n关联规则分析\n支持度,置信度,提升度\n\n\n\n\n\n\n\n\n\n\n\n{啤酒}→{尿布}的支持度： 𝑁1&#x2F;𝑁4{尿布}→{啤酒}的支持度： 𝑁1&#x2F;𝑁4  \n\n{啤酒}→{尿布}的置信度： 𝑁1&#x2F;𝑁2{尿布}→{啤酒}的置信度： 𝑁1&#x2F;𝑁3  \n\n{啤酒}→{尿布}的提升度： (𝑁1&#x2F;𝑁2)&#x2F;(𝑁3&#x2F;𝑁4){尿布}→{啤酒}的提升度： (𝑁1&#x2F;𝑁3)(𝑁2&#x2F;𝑁4)\n先购买A对购买B的概率的提升作用，即\n置信度(𝑁1&#x2F;𝑁3)&#x2F;后者在总销售记录中的比例(𝑁2&#x2F;𝑁4)  的比值  \n\n关联规则算法:\n\n\n\n\n\n\n\n\n\n目的:以超市销售数据为例，提取关联规则的最大困难在于当存在很多商品时，可能的商品的组合（规则的前项与后项）的数目会达到一种令人望而却步的程度。因而各种关联规则分析的算法从不同方面入手减小可能的搜索空间的大小以及减小扫描数据的次数。  \n\nApriori 关联规则最常用也是最经典的挖掘频繁项集的算法，其核心思想是通过连接产生候选项及其支持度然后通过剪枝生成频繁项集\n在频繁项集𝐿1 、 𝐿2和𝐿3的基础上，计算置信度，得到相应的关联规则  \n\n\n只有&gt;50%的才是有效规则!因为置信度阈值设置为了50%\n\nFP-Tree 针对Apriori算法的固有的多次扫描事务数据集的缺陷，提出的不产生候选频繁项集的方法。Apriori和FP-Tree都是寻找频繁项集的算法\n\n\n\n案例:教材只给出了Apriori算法的案例实现\n\n步骤:\nloadData 加载数据并初始化\nfindFreqItemsets 查找频繁项集\ngenerateRules 生成关联规则\n\n\n\n\n\n\n\n\n\n商品：评分为5的电影的movieId(因为评分为5的电影也有很多,有极大的可筛选空间)一个购物篮：每个用户所查看的movie放在同一个购物篮,但老师提供的源数据并非这种形式,所以我们要进行数据处理\nStep1:数据处理并把处理后的数据写入index.file,\n源数据:\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-8PqqolFr-1651042249362)(数据分析-MATLAB.assets&#x2F;image-20211209191007710.png)]\n%数据处理并把处理后的数据写入index.file,以电影ID\nuserId &#x3D; ratings.userId;\nmovieId &#x3D; ratings.movieId;\nrating &#x3D; ratings.rating;\n\nfid&#x3D;fopen(&#39;input.txt&#39;,&#39;w&#39;);\nfor k &#x3D; 1:610\n    %同一用户ID,且评分大于5的电影,在同一行\n    index &#x3D; userId&#x3D;&#x3D;k &amp; rating&#x3D;&#x3D;5;\n    \n    %[m,n] &#x3D; size(find(index));if(m&gt;0)是为了杜绝空行输入input.txt\n    [m,n] &#x3D; size(find(index));\n    if(m&gt;0)\n       fprintf(fid,&#39;%d,&#39;,movieId(index));\n       fprintf(fid,&#39;\\n&#39;); \n    end\n    \nend\nfclose(fid);\n\n 处理结果(共计五百多行(去除了610行里的空行),仅截取部分):\n\nStep2:使用Apriori算法(调用相关函数,函数在报告最下面)挖掘关联规则(由于样本太过稀疏,我们支持度阈值可以低一些,minSup &#x3D; 0.05; % 最小支持度;minConf &#x3D; 0.5;% 最小置信度)\n%% 使用Apriori算法挖掘关联规则\nclear;\n% 参数初始化\ninputfile &#x3D; &#39;input.txt&#39;; % 属性数据\noutputfile&#x3D;&#39;as.txt&#39;;% 输出转换后0,1矩阵文件\nminSup &#x3D; 0.05; % 最小支持度\nminConf &#x3D; 0.5;% 最小置信度\nnRules &#x3D; 1000;% 输出最大规则数\nsortFlag &#x3D; 1;% 按照支持度排序\nrulefile &#x3D; &#39;rules.txt&#39;; % 规则输出文件\n\n%% 调用转换程序 ，把数据转换为0,1矩阵，自定义函数\n[transactions,code] &#x3D; trans2matrix(inputfile,outputfile,&#39;,&#39;); \n\n%% 调用Apriori关联规则算法，自定义函数\n[Rules,FreqItemsets] &#x3D; findRules(transactions, minSup, minConf, nRules, sortFlag, code, rulefile);\n\ndisp(&#39;Apriori算法挖掘数据关联规则完成！&#39;);\n\n\n\n\n输出结果截取(共计256条规则,):\n\n(仅从规则中截取部分)\n从10万条数据中得到了256条规则,可以看到,整体效果较好\n调用函数:\ntrans2matrix: txt文件转矩阵\nfunction [ output,code] &#x3D; trans2matrix( inputfile,outputfile,splitter )\n%% 把输入事务转换为0、1矩阵；每行代表一个事务\n\n% 输入参数：\n% inputfile：输入文件，空格分隔每个项目；\n% outputfile：输出文件，转换后的0,1矩阵文件；\n% splitter: 输入文件项目的间隔符,默认为空格\n\n% 输出参数：\n% output : 转换后的0,1 矩阵\n% code：编码规则；\n\nif nargin&lt;3\n   splitter&#x3D;&#39; &#39;; \nend\n\n%% 读入文件, 获得编码规则\ncode&#x3D;&#123;&#125;;\nfid&#x3D; fopen(inputfile);\ntline &#x3D; fgetl(fid);\nlines&#x3D;0;\nwhile ischar(tline)\n    lines&#x3D;lines+1; % 记录行数\n    tline &#x3D; deblank(tline);\n    tline &#x3D; regexp(tline,splitter,&#39;split&#39;);\n    code&#x3D;[code tline]; % 合并 \n    code &#x3D; unique(code); % 去除重复记录\n%     disp(code)\n    tline &#x3D; fgetl(fid);\nend\ndisp(&#39;编码规则为：&#39;)\ndisp(num2str(1:size(code,2)))\ndisp( code);\nfclose(fid); % 关闭文档\n\n%% 读取文件，根据编码规则对原始数据进行转换\nitemsnum&#x3D; size(code,2);\noutput&#x3D;zeros(lines,itemsnum);\nfid&#x3D; fopen(inputfile);\ntline &#x3D; fgetl(fid);\nlines&#x3D;0;\nwhile ischar(tline)\n    lines&#x3D;lines+1; % 记录行数\n    tline &#x3D; deblank(tline);\n    tline &#x3D; regexp(tline,splitter,&#39;split&#39;);\n    [~,icode,~] &#x3D; intersect(code,tline);% 寻找下标\n    output(lines,icode&#39;)&#x3D;1;\n    %disp(output(lines,:))\n    tline &#x3D; fgetl(fid);\nend\nfclose(fid);\n\n%% 把转换后的矩阵写入文件\nfid &#x3D; fopen(outputfile, &#39;w&#39;);\nfor i&#x3D;1:lines\n   fprintf(fid,&#39;%s\\n&#39;,num2str(output(i,:))); \nend\nfclose(fid);\nend\n\n\n\nfindRules: 算法核心,找出关联规则\nfunction [Rules,FreqItemsets] &#x3D; findRules(transactions, minSup, minConf, nRules, sortFlag, code, rulesfile)\n%\n% This function performs Association Analysis (Apriori Algorithm):  Given a set of transactions,\n% find rules that will predict  the occurrence of an item based on the occurrences of other\n% items in the transaction\n% \n% Rules are of the form  A-&gt; B (e.g., &#123;milk, diaper&#125; - &gt; &#123;Coke&#125;), where\n% support &#x3D; minSup (minimum support threshold)\n% confidence &#x3D; minConf (minimum confidence threshold)\n% \n% Support is the fraction of transactions that contain both A and B:\n% Support(A,B) &#x3D; P(A,B)\n% \n% Confidence is the fraction of transactions where items in B appear in transactions  that contain A:\n% Confidence(A,B) &#x3D; P(B|A)\n%\n%\n% INPUT:\n%          transactions:  M x N matrix of binary transactions, where each row\n%                                  represents one transaction and each column represents\n%                                  one attribute&#x2F;item\n%          minSup:          scalar value that represents the minimum\n%                                  threshold for support for each rule\n%          minConf:        scalar value that represents the minimum\n%                                  threshold for confidence of each rule\n%          nRules:           scalar value indicating the number of rules\n%                                  the user wants to find\n%          sortFlag:         binary value indicating if the rules should be\n%                                  sorted by support level or confidence level\n%                                  1: sort by rule support level\n%                                  2: sort by rule confidence level\n%          code (labels): 编码规则            optional parameter that provides labels for\n%                                  each attribute (columns of transactions),\n%                                  by default attributes are represented\n%                                  with increasing numerical values 1:N\n%           \n%          fname:            optional file name where rules are saved\n%\n% OUTPUT:\n%          Rules:             2 x 1 cell array, where the first cell (Rules&#123;1&#125;&#123;:&#125;)\n%                                 contains the itemsets in the left side of the rule and second\n%                                 cell (Rules&#123;2&#125;&#123;:&#125;) contains the itemsets\n%                                 in the right side of the rule (e.g., if\n%                                 the first rule is &#123;1, 2&#125; -&gt; 3,\n%                                 Rules&#123;1&#125;&#123;1&#125; &#x3D; [1,2], Rules&#123;2&#125;&#123;1&#125; &#x3D; [3])\n%         FreqItemsets: A cell array of frequent itemsets of size 1, 2,\n%                                 etc., with itemset support &gt;&#x3D; minSup,\n%                                 where FreqItemSets&#123;1&#125; represents itemsets\n%                                 of size 1, FreqItemSets&#123;2&#125; itemsets of\n%                                 size 2, etc.\n%         fname.txt:      The code creates a text file and stores all the\n%                                 rules in the form left_side -&gt; right_side.\n%\n% author: Narine Manukyan 07&#x2F;08&#x2F;2013\n\n% Number of transactions in the dataset\nM &#x3D; size(transactions,1);\n% Number of attributes in the dataset\nN &#x3D; size(transactions,2);\n\nif nargin &lt; 7\n    fname &#x3D; &#39;default&#39;;\nend\n\nif nargin &lt; 6\n    labels &#x3D; cellfun(@(x)&#123;num2str(x)&#125;, num2cell(1:N));\nend\n\nif nargin &lt; 5\n    sortFlag &#x3D; 1;\nend\n\nif nargin &lt; 4\n    nRules &#x3D; 100;\nend\n\nif nargin &lt; 3\n    minConf &#x3D; 0.5;\nend\n\nif nargin &lt; 2\n    minSup &#x3D; 0.5;\nend\n\nif nargin &#x3D;&#x3D; 0\n    error(&#39;No input arguments were supplied.  At least one is expected.&#39;);\nend\n\n% Preallocate memory for Rules and FreqItemsets\nmaxSize &#x3D; 10^2;\nRules &#x3D; cell(2,1);\nRules&#123;1&#125; &#x3D; cell(nRules,1);\nRules&#123;2&#125; &#x3D; cell(nRules,1);\nFreqItemsets &#x3D; cell(maxSize);\nRuleConf &#x3D; zeros(nRules,1);\nRuleSup &#x3D; zeros(nRules,1);\nct &#x3D; 1;\n\n% Find frequent item sets of size one (list of all items with minSup)\nT &#x3D; [];\nfor i &#x3D; 1:N\n    S &#x3D; sum(transactions(:,i))&#x2F;M;\n    if S &gt;&#x3D; minSup\n        T &#x3D; [T; i];\n    end\nend\nFreqItemsets&#123;1&#125; &#x3D; T;\n\n%Find frequent item sets of size &gt;&#x3D;2 and from those identify rules with minConf\n\nfor steps &#x3D; 2:N\n\n    % If there aren&#39;t at least two items  with minSup terminate\n    U &#x3D; unique(T);\n    if isempty(U) || size(U,1) &#x3D;&#x3D; 1\n        Rules&#123;1&#125;(ct:end) &#x3D; [];\n        Rules&#123;2&#125;(ct:end) &#x3D; [];\n        FreqItemsets(steps-1:end) &#x3D; [];\n        break\n    end\n\n    % Generate all combinations of items that are in frequent itemset\n    Combinations &#x3D; nchoosek(U&#39;,steps);\n    TOld &#x3D; T;\n    T &#x3D; [];\n\n    for j &#x3D; 1:size(Combinations,1)\n        if ct &gt; nRules\n            break;\n        else\n            % Apriori rule: if any subset of items are not in frequent itemset do not\n            % consider the superset (e.g., if &#123;A, B&#125; does not have minSup do not consider &#123;A,B,*&#125;)\n            if sum(ismember(nchoosek(Combinations(j,:),steps-1),TOld,&#39;rows&#39;)) - steps+1&gt;0\n\n                % Calculate the support for the new itemset\n                S &#x3D; mean((sum(transactions(:,Combinations(j,:)),2)-steps)&gt;&#x3D;0);\n                if S &gt;&#x3D; minSup\n                    T &#x3D; [T; Combinations(j,:)];\n\n                    % Generate potential rules and check for minConf\n                    for depth &#x3D; 1:steps-1\n                        R &#x3D; nchoosek(Combinations(j,:),depth);\n                        for r &#x3D; 1:size(R,1)\n                            if ct &gt; nRules\n                                break;\n                            else\n                                % Calculate the confidence of the rule\n                                Ctemp &#x3D; S&#x2F;mean((sum(transactions(:,R(r,:)),2)-depth)&#x3D;&#x3D;0);\n                                if Ctemp &gt; minConf\n\n                                    % Store the rules that have minSup and minConf\n                                    Rules&#123;1&#125;&#123;ct&#125; &#x3D; R(r,:);\n                                    Rules&#123;2&#125;&#123;ct&#125; &#x3D; setdiff(Combinations(j,:),R(r,:));\n                                    RuleConf(ct) &#x3D; Ctemp;\n                                    RuleSup(ct) &#x3D; S;\n                                    ct &#x3D; ct+1;\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n\n    % Store the freqent itemsets\n    FreqItemsets&#123;steps&#125; &#x3D; T;\nend\n\n% Get rid of unnecessary rows due to preallocation (helps with speed)\nFreqItemsets(steps-1:end) &#x3D; [];\nRuleConf &#x3D; RuleConf(1:ct-1);\nRuleSup &#x3D; RuleSup(1:ct-1);\n\n% Sort the rules in descending order based on the confidence or support level\nswitch sortFlag\n    case 1 % Sort by Support level\n        [V,ind] &#x3D; sort(RuleSup,&#39;descend&#39;);\n    case 2 % Sort by Confidence level\n        [V,ind] &#x3D; sort(RuleConf,&#39;descend&#39;);\nend\n\nRuleConf &#x3D; RuleConf(ind);\nRuleSup &#x3D; RuleSup(ind);\n\nfor i &#x3D; 1:2\n    temp &#x3D; Rules&#123;i,1&#125;;\n    temp &#x3D; temp(ind);\n    Rules&#123;i,1&#125; &#x3D; temp;\nend\n\ndisp([&#39;关联规则算法完成,规则数为：&#39; num2str(size(RuleSup,1))]);\n\n% Save the rule in a text file and print them on display\nfid &#x3D; fopen(rulesfile, &#39;w&#39;);\nfprintf(fid, &#39;%s   (%s, %s) \\n&#39;, &#39;Rule&#39;, &#39;Support&#39;, &#39;Confidence&#39;);\n\nfor i &#x3D; 1:size(Rules&#123;1&#125;,1)\n    s1 &#x3D; &#39;&#39;;\n    s2 &#x3D; &#39;&#39;;\n    for j &#x3D; 1:size(Rules&#123;1&#125;&#123;i&#125;,2)\n        if j &#x3D;&#x3D; size(Rules&#123;1&#125;&#123;i&#125;,2)\n            s1 &#x3D; [s1 code&#123;Rules&#123;1&#125;&#123;i&#125;(j)&#125;];\n        else\n            s1 &#x3D; [s1 code&#123;Rules&#123;1&#125;&#123;i&#125;(j)&#125; &#39;,&#39;];\n        end\n    end\n    for k &#x3D; 1:size(Rules&#123;2&#125;&#123;i&#125;,2)\n        if k &#x3D;&#x3D; size(Rules&#123;2&#125;&#123;i&#125;,2)\n            s2 &#x3D; [s2 code&#123;Rules&#123;2&#125;&#123;i&#125;(k)&#125;];\n        else\n            s2 &#x3D; [s2 code&#123;Rules&#123;2&#125;&#123;i&#125;(k)&#125; &#39;,&#39;];\n        end\n    end\n    s3 &#x3D; num2str(RuleSup(i)*100);\n    s4 &#x3D; num2str(RuleConf(i)*100);\n    fprintf(fid, &#39;%s -&gt; %s  (%s%%, %s%%)\\n&#39;, s1, s2, s3, s4);\nend\nfclose(fid);\ndisp([&#39;存储规则到文件‘&#39; rulesfile &#39;’完成&#39;])\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMOOC作业九:\n%数据处理并把处理后的数据写入input.file\n%导入表格前信息做了排序,1:22063为0,即女,20264:43386为1,即男\n\nfid&#x3D;fopen(&#39;input1.txt&#39;,&#39;w&#39;);\nfor k &#x3D; 1:20263\n    %将所有女性用户中买过的商品所在列的下标打印,(前两列为性别,时间,所以下标从第三列开始.我们最终根据下标就能判断商品种类)\n    fprintf(fid,&#39;%d,&#39;,find(Untitled(k,:)&#x3D;&#x3D;1));\n    fprintf(fid,&#39;\\n&#39;);\nend\nfclose(fid);\n\nfid&#x3D;fopen(&#39;input2.txt&#39;,&#39;w&#39;);\nfor k &#x3D; 20264:43386\n    %将所有男性用户中买过的商品所在列的下标打印,(前两列为性别,时间,所以下标从第三列开始.我们最终根据下标就能判断商品种类)\n    fprintf(fid,&#39;%d,&#39;,find(Untitled(k,3:)&#x3D;&#x3D;1));\n    fprintf(fid,&#39;\\n&#39;);\nend\nfclose(fid);\n\n%% 使用Apriori算法挖掘关联规则\nclear;\n% 参数初始化\ninputfile &#x3D; &#39;input1.txt&#39;; % 属性数据\noutputfile&#x3D;&#39;as.txt&#39;;% 输出转换后0,1矩阵文件\nminSup &#x3D; 0.05; % 最小支持度\nminConf &#x3D; 0.5;% 最小置信度\nnRules &#x3D; 1000;% 输出最大规则数\nsortFlag &#x3D; 1;% 按照支持度排序\nrulefile1 &#x3D; &#39;rules1.txt&#39;; % 规则输出文件\nrulefile2 &#x3D; &#39;rules2.txt&#39;; % 规则输出文件\n\n%% 调用转换程序 ，把数据转换为0,1矩阵，自定义函数\n[transactions,code] &#x3D; trans2matrix(inputfile,outputfile,&#39;,&#39;); \n\n%% 调用Apriori关联规则算法，自定义函数\n[Rules,FreqItemsets] &#x3D; findRules(transactions, minSup, minConf, nRules, sortFlag, code, rulefile);\n\ndisp(&#39;Apriori算法挖掘数据关联规则完成！&#39;);\n%%调用的相关函数可在matlab官网找到,代码较长,不再附上\n\n\n\n运行结果:\n\n得到的部分关联规则:\n女性:\n\n由此可见,对女性而言,购买:\n133:431066:DINING 餐具\n29:102018: CHINESE DESSERT中式甜点\n41:102056:VENDOR BREAD供应商自制面包\n后,往往会购买:\n47:103116:FRESH SOY&#x2F;FLOUR&#x2F;RICE PRODUCTS新鲜豆制品&#x2F;米面制品\n得到的部分男性关联规则:\n\n由此可见,对于男性而言,购买:\n3:101001:BEVERAGE饮料\n103005:CANNED FOOD罐头食品\n118:328041:MANS WEAR 男装\n往往会购买:\n48:213018:LIQUOR酒类\n由此可见,这些关联规则还是比较符合实际的\n\n**LAB 9:**综合分析(实则就是数据处理+最常见的聚类)\n\n构造各项指标,并进行一定处理:\n\n%提取构造LRFMC指标，具体构造过程为：\nL&#x3D;airdata.LOAD_TIME-airdata.FFP_DATE;\nR&#x3D;airdata.LAST_TO_END;\nF&#x3D;airdata.FLIGHT_COUNT;\nM&#x3D;airdata.SEG_KM_SUM;\nC&#x3D;airdata.avg_discount;\n\n\n%寻找异常值\nfind(L&lt;&#x3D;0)\nfind(L&lt;&#x3D;0)\nfind(F&lt;&#x3D;0)\nfind(M&lt;&#x3D;0)\n%寻找avg_discount平均折扣率&lt;0或&gt;1的异常情况\nfind(C&gt;1 | C&lt;0)\n\n结果如下:\n\n说明存在avg_discount平均折扣率&lt;0或&gt;1的异常情况,去除这些数据;并进行数据标准化\n%去掉avg_discount平均折扣率&lt;0或&gt;1的异常情况\nindex&#x3D;find(C&gt;1 | C&lt;0);\nL(index)&#x3D;[];\nR(index)&#x3D;[];\nF(index)&#x3D;[];\nM(index)&#x3D;[];\nC(index)&#x3D;[];\n\n\n%处理后的数据,利用zscore函数进行标准差标准化后\ndata&#x3D;[L,R,F,M,C];\ndata&#x3D;zscore(data);\n\n\n\n\n\n\n聚类:将客户分成五个级别:\n\n%%选择5作为聚类数,进行聚类\n% 参数初始化\nk &#x3D; 5; % 聚类的类别\niteration &#x3D;500 ; % 聚类最大循环次数\ndistance &#x3D; &#39;sqEuclidean&#39;; % 距离函数\n% 调用kmeans算法\nopts &#x3D; statset(&#39;MaxIter&#39;,iteration);\n[IDX,C,sumd,D] &#x3D; kmeans(data,k,&#39;distance&#39;,distance,&#39;Options&#39;,opts);\n\n\n\n统计各类中的客户数分布:\nhistogram(IDX)\n\n\n\n\n以及各类的LRFMC指标对应的概率密度:\n(五种颜色的曲线对应五种类,legend见右上)\nL：会员入会时间距观测窗口结束的月数,\nhold on;\n%做L指标的概率分布图\nfor t&#x3D;1:5 \n    cdfplot(L(find(IDX&#x3D;&#x3D;t)));\nend\nlegend(&#39;Cluster 1&#39;,&#39;Cluster 2&#39;,&#39;Cluster 3&#39;,&#39;Cluster 4&#39;,&#39;Cluster 5&#39;)\n\n\n\n\nR,F,M,C 频率分布图:\nhold on;\n%依次做RFMC指标的概率分布图\nfor t&#x3D;1:5    \n    cdfplot(R(find(IDX&#x3D;&#x3D;t)));&#x2F;&#x2F;F,M,C的代码同,不再赘述\nend\nlegend(&#39;Cluster 1&#39;,&#39;Cluster 2&#39;,&#39;Cluster 3&#39;,&#39;Cluster 4&#39;,&#39;Cluster 5&#39;)\n\n\n\nR:客户最近一次乘坐公司飞机距观测窗口结束的月数；\n\nF:客户在观测窗口内乘坐公司飞机的次数；\n\nM:客户在观测窗口内乘坐公司飞机的总里程；\n\nC:客户在观测窗口内乘坐舱位所对应的折扣系数的平均值。\n\n并分析类标号（15）与聚类目标（AE）的对应关系:\n重要保持客户（A）、重要发展客户（B）、重要挽留客户（C）、一般客户（D）、低价值客户（E）\nL：会员入会时间距观测窗口结束的月数；\nR：客户最近一次乘坐公司飞机距观测窗口结束的月数；\nF：客户在观测窗口内乘坐公司飞机的次数；\nM：客户在观测窗口内乘坐公司飞机的总里程；\nC：客户在观测窗口内乘坐舱位所对应的折扣系数的平均值。\nL越长,R越小(该指标受观测窗口时间印象,仅具有一定参考价值),F越大,M越大,C越小,用户价值越高\n根据各主要指标:(&gt;表示更具价值)\n人数比例:1:2:3:4:5 &#x3D; 3:2:1:4:2\nL:1&gt;3&gt;5&gt;2&gt;4  反应客户新老度,忠诚度\nR:3&gt;4&gt;1&gt;2&gt;5   一定程度上能反应近期客户乘机频率(只具有一定参考价值)\nF:4&gt;&gt;2≈5&gt;3&gt;1    反应客户乘机次数\nM:3&gt;&gt;4≈1&gt;2&gt;5    反应客户乘机里程\nC:2&gt;&gt;1≈3≈4≈5    反应客户乘机舱位层次高低,折扣系数越小,舱位越高级,可攫取利润越高\n由此,可得以下关系:,\n重要保持客户（A） cluster2:舱位层次高,乘机相对频繁\n重要发展客户（B）cluster4:乘机次数和近期乘机次数高,且用户较新,具备发展潜力\n重要挽留客户（C）cluster3:乘机里程和近期乘机次数较高,且用户较老,总量最大,需重点挽留\n一般客户（D）cluster1:总量相对较大,乘机里程一般,乘机舱位普通,老用户,乘机次数较少\n低价值客户（E）cluster5,注册相对较久,但乘机次数较少,乘机里程最少,舱位普通\n\n【非计算机专业学生选做】评估聚类质量(本人非计算机专业)\n\n3.根据你所选择的K-means聚类方法，选择F统计量作为评价指标，对聚类效果进行分析。\n指标选用来自PPT:\n\nm&#x3D;mean(data);\na&#x3D;sum(dist(C,m&#39;));\nb&#x3D;(sumd).^0.5;\nF&#x3D;abs(a.&#x2F;b-1)\n\n结果:\n\n该聚类方案 LRFMC五大指标的F统计量 都接近于1,聚类效果较好.但毫无疑问的是,LRFMC五大指标各有侧重点,反应用户了用户忠诚度(新老用户),乘机频率,乘机舱位高低等不同价值,在重要度上也理应占有不同权值,更具有着不同的评估意义.所以执着于聚类数据上的效果而忽略了实际效果,是没有意义的.\n","slug":"数据科学基础-MATLAB-Note","date":"2022-10-06T13:54:25.000Z","categories_index":"","tags_index":"MATLAB,Machine Learing Basis,data mining","author_index":"Statck"},{"id":"420d80760a809005a67319349e243832","title":"黑马程序员ssm总结","content":"前言\n\n\n\n\n\n\n\n\n\npdf+源码(大全),对应视频:https://www.bilibili.com/video/BV1VJ411X7xX?p=20&amp;vd_source=0e4ada3d15f80172cb72c52e0fcabd05自我感觉黑马课程比官方文档好,新手友好,强推!看文档必看视频效率高,理解更透,一遍看不懂,反复看!黑马程序员ssm资料(从spring–&gt;springmvc–&gt;springboot–&gt;maven高级-&gt;cloud微服务)\n@[toc]\n耦合性可以是低耦合性（或称为松散耦合），也可以是高耦合性（或称为紧密耦合）。以下列出一些耦合性的分类，从高到低依序排列：\n\n内容耦合（content coupling，耦合度最高）：也称为病态耦合（pathological coupling）当一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部。\n共用耦合&#x2F;公共耦合（common coupling）：也称为全局耦合（global coupling.）指通过一个公共数据环境相互作用的那些模块间的耦合。公共耦合的复杂程序随耦合模块的个数增加而增加。\n外部耦合（external coupling）：发生在二个模块共用一个外加的数据格式、通信协议或是设备界面，基本上和模块和外部工具及设备的沟通有关。\n控制耦合（control coupling）：指一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内某一功能;\n特征耦合&#x2F;标记耦合（stamp coupling）：也称为数据结构耦合，是指几个模块共享一个复杂的数据结构，如高级语言中的数组名、记录名、文件名等这些名字即标记，其实传递的是这个数据结构的地址;\n数据耦合&#x2F;数据耦合（data coupling）：是指模块借由传入值共享数据，每一个数据都是最基本的数据，而且只分享这些数据（例如传递一个整数给计算平方根的函数）。\n消息耦合（message coupling，是无耦合之外，耦合度最低的耦合）：可以借由以下二个方式达成：状态的去中心化（例如在对象中），组件间利用传入值或消息传递 (计算机科学)来通信。\n无耦合：模块完全不和其他模块交换信息。\n\n降低耦合度的方法 \n　　1、少使用类的继承，多用接口隐藏实现的细节。 java面向对象编程引入接口除了支持多态外， 隐藏实现细节也是其中一个目的。　　2、模块的功能化分尽可能的单一，道理也很简单，功能单一的模块供其它模块调用的机会就少。（其实这是高内聚的一种说法，高内聚低耦合一般同时出现，为了限制篇幅，我们将在以后的版期中讨论）。　　3、遵循一个定义只在一个地方出现。　　4、少使用全局变量。　　5、类属性和方法的声明少用public，多用private关键字，　　6、多用设计模式，比如采用MVC的设计模式就可以降低界面与业务逻辑的耦合度。　　7、尽量不用“硬编码”的方式写程序，同时也尽量避免直接用SQL语句操作数据库。　　8、最后当然就是避免直接操作或调用其它模块或类（内容耦合）；如果模块间必须存在耦合，原则上尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，避免使用内容耦合。\n紧密耦合的系统在开发阶段有以下的缺点：\n\n一个模块的修改会产生涟漪效应，其他模块也需随之修改。\n由于模块之间的相依性，模块的组合会需要更多的精力及时间。\n由于一个模块有许多的相依模块，模块的可复用性低。 [2]\n\n\nspring核心容器\n\n\n\n\n\n\n\n\n本章是core&amp;bean的原理讲解\n5min复习视频:核心容器总结\n\n\n\n\n\n\n\n\n\n\nSpring就提出了一个解决方案:\n\n使用对象时，在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象\n即:使用消息耦合(耦合度最低的耦合),去中心化,\n\n\n&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;\n\n(1)什么是控制反转呢？\n\n使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。\n\n2.DI的注入方法\n\nsetter注入(比构造器注入更常用,推荐,我们一般只用构造器注入)&lt;property&gt;(又分为\n\n引用类型注入&lt;property name&#x3D;”bookDao” ref&#x3D;”bookDao”&gt;)\n\n简单类型(int…String)注入&lt;property name&#x3D;”msg” ref&#x3D;”我的类型是自动检测的,看要被注入的变量的类型”&gt;)\n\n集合类型注入\n&lt;property name&#x3D;&quot;names&quot;&gt;\n    &lt;list&gt;\n        &lt;value&gt;xxx&lt;&#x2F;value&gt;\n        &lt;ref bean&#x3D;&quot;dataSource&quot;&#x2F;&gt;\n    &lt;list&gt;\n&lt;&#x2F;property&gt;\n\n\n构造器注入&lt;constructor-arg&gt;\n\n\nIoC基础上,需要绑定两个Bean之间的依赖关系,需要DI进行绑定,&lt;property&gt;的形式\n3.bean的生命周期scope: &lt;bean id&#x3D;”bookDao” class&#x3D;”com.itheima.dao.impl.BookDaoImpl” init-method&#x3D;”init” destroy-method&#x3D;”destory”&#x2F; …&gt;当然,还有很多别的scope生命周期属性\n\n\nspring注解开发(正片开始)spring3.0升级了\n纯注释开发,使用一个添加了 @configuration的config配置类来进行配置\nspring注解开发总结\n\n普通配置类注入:\n\n第三方配置类注入\n\n\n\n\n\nspring整合mybatis看看就行\n可以看到,在老师给的项目中,shiro( shiro是apache的是一个分布式权限管理的框架，实现 用户认证、用户授权)\n和 cors(用于允许跨域请求)\n\n\n\n\n\n\n\n\n\n出于安全原因，浏览器禁止AJAX调用当前来源之外的资源，跨域资源共享（CORS）是由大多数浏览器实施的W3C规范，使您可以灵活地指定对哪种跨域请求进行授权。从Spring Framework 4.2开始，开箱即用地支持CORS。 CORS请求（包括带有OPTIONS方法的预检请求）将自动分派到各种已注册的HandlerMappings。\n二者采取了类似的配置类形式\nspring整合Junit看看就行\n\n\nAOP:用于不改变原代码基础上 进行功能增强\n概念：AOP(Aspect Oriented Programming)面向切面编程，一种编程范式\n作用：在不惊动原始设计的基础上为方法进行功能&#x3D;&#x3D;增强&#x3D;&#x3D;\n核心概念\n代理（Proxy）：SpringAOP的核心本质是采用代理模式实现的\n连接点（JoinPoint）：在SpringAOP中，理解为任意方法的执行\n切入点（Pointcut）：匹配连接点的式子，也是具有共性功能的方法描述\n通知（Advice）：若干个方法的共性功能，在切入点处执行，最终体现为一个方法\n切面（Aspect）：描述通知与切入点的对应关系\n目标对象（Target）：被代理的原始对象成为目标对象\n\n\n\n切入点表达式:\n\n切入点表达式标准格式：动作关键字(访问修饰符  返回值  包名.类&#x2F;接口名.方法名（参数）异常名)\nexecution(* com.itheima.service.*Service.*(..))\n\n切入点表达式描述通配符：\n\n作用：用于快速描述，范围描述\n*：匹配任意符号（常用）\n.. ：匹配多个连续的任意符号（常用）\n+：匹配子类类型\n\n\n切入点表达式书写技巧\n1.按&#x3D;&#x3D;标准规范&#x3D;&#x3D;开发2.查询操作的返回值建议使用*匹配3.减少使用..的形式描述包4.&#x3D;&#x3D;对接口进行描述&#x3D;&#x3D;，使用*表示模块名，例如UserService的匹配描述为*Service5.方法名书写保留动词，例如get，使用*表示名词，例如getById匹配描述为getBy*6.参数根据实际情况灵活调整\n\n\n\nSpring事务\n保障一系列的数据库操作同成功同失败\nSpring事务作用：在数据层或**&#x3D;&#x3D;业务层&#x3D;&#x3D;**保障一系列的数据库操作同成功同失败\nSpring为了管理事务，提供了一个平台事务管理器PlatformTransactionManager:\n\n\n进行提交与回滚,事务(转账操作中:A钱-,B钱+)作为一个整体,一旦部分执行不成功,能够整个回滚,从而确保若:A-成功,B+失败后,A,B都将回滚,恢复原状态\n\n\n(springboot中,连SpringMvcConfig都没了,使用,@EnableWebMvc也不会用了)\nREST风格(只是一种风格,不是一种规范,可以不遵守,但由于采用的人多,已经接近于一种规范):\n\nRestful风格:基于Rest风格,进一步简化:\n@ResponseBody\n@RestController\n@RequestMapping\n\nPostMan请求管理规范:\n\n使用Restful风格进行开发的一个示例:\n\n如果直接访问前端界面:localhost&#x2F;pages&#x2F;books.html,报错:\n\n浏览器:\n因:浏览器访问使用get方法,由spring处理,spring认为你没有这一接口.确实,它本来也不是接口,而是一个页面.\n法:spring放行,让tomcat处理；即：实现一个过滤器（filter）静态页面，tomcat直接处理，动态请求springMVC处理\n拦截器：\n\n拦截器（Intercepter）是一种动态拦截方法调用的机制，在springMVC中动态拦截 控制器 方法的执行\n\n在指定方法的前后执行预先设定的代码\n阻止原始方法的执行\n\n拦截器与过滤器的区别：\n\nfilter属于servlet技术，intercepter属于SpringMVC技术\nfilter对所有访问进行增强，intercepter仅对SpringMVC的访问进行增强\n\n\nMaven分模块开发：idea的maven相关功能只能确保书写的时候不报错，不能保证运行的时候不报错\n通过install，实现本地安装\npom项目默认的打包方式:&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;\npom项目web项目的打包方式:&lt;packaging&gt;war&lt;&#x2F;packaging&gt;\npom项目聚合项目的打包方式:&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n\nmaven冲突:\n\n\n发生冲突时,maven会有一些规则来选用依赖\n依赖冲突可能会导致某个依赖使用了你不想使用的版本(这个版本可能会导致运行错误)\n\n可选依赖和排除依赖\n\n\n\n\n\n\n\n\n\n&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;\n&lt;optional&gt;true&lt;/optional&gt;\n\n\n\n\n\n\n\n\n\n\n&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;\n&lt;exclusions&gt;\n    &lt;exclusion&gt;\n        &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n        &lt;artifactId&gt;maven_03_pojo&lt;/artifactId&gt;\n    &lt;/exclusion&gt;\n&lt;/exclusions&gt;\n\n\nmaven多环境开发:(profile)\n\n\n\npro,dev,test多环境不同,如何配置多环境开发,以供选用?\n\n使用聚合统一管理项目\n步骤1:创建一个空的maven项目\n步骤2:将项目的打包方式改为pom\n步骤3:pom.xml添加所要管理的项目\n步骤4:使用聚合统一管理项目\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;\n    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;\n    \n    &lt;!--设置管理的模块名称--&gt;\n    &lt;modules&gt;\n        &lt;module&gt;..&#x2F;maven_02_ssm&lt;&#x2F;module&gt;\n        &lt;module&gt;..&#x2F;maven_03_pojo&lt;&#x2F;module&gt;\n        &lt;module&gt;..&#x2F;maven_04_dao&lt;&#x2F;module&gt;\n    &lt;&#x2F;modules&gt;\n&lt;&#x2F;project&gt;\n\n继承:解决重复配置问题\n\n\n&lt;!--配置当前工程继承自parent工程--&gt;\n&lt;parent&gt;\n    &lt;groupId&gt;com.itheima&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;maven_01_parent&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-RELEASE&lt;&#x2F;version&gt;\n    &lt;!--设置父项目pom.xml位置路径--&gt;\n    &lt;relativePath&gt;..&#x2F;maven_01_parent&#x2F;pom.xml&lt;&#x2F;relativePath&gt;\n&lt;&#x2F;parent&gt;\n\n\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;&lt;dependencyManagement&gt;标签不真正引入jar包，而是配置可供子项目选择的jar包依赖&#x3D;&#x3D;\n子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定&lt;version&gt;\n\n属性:即在pom.xml中配置属性变量,更改一处时,其他地方跟着更改\n定义:\n&lt;!--定义属性--&gt;\n&lt;properties&gt;\n    &lt;spring.version&gt;5.2.10.RELEASE&lt;&#x2F;spring.version&gt;\n    &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;\n    &lt;mybatis-spring.version&gt;1.3.0&lt;&#x2F;mybatis-spring.version&gt;\n&lt;&#x2F;properties&gt;\n\n使用:\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n文件加载 属性:配置文件(如jdbc.properties文件)中的属性，也让Maven进行管理\n\n\n\n\n\n\n\n\n\n需要设置maven过滤文件范围\n详见 maven高级.md\n\n私服\n\n\n使用nexus能建立私服仓库(小团队开发):nexus server端建立私服仓库–&gt;本地maven setting.xml完成私服地址配置(至此,能访问私服了)–&gt;项目pom.xml,添加 &lt;distributionManagement&gt; 配置当前工程保存(部署)在私服中的具体位置–&gt;maven deploy指令部署\n(下载不需要部署)\n\nspringboot(前期都是基础,了解原理;springboot开始进入实用)\n一个经典Controller处理前端请求:\n@RestController\n@RequestMapping(&quot;&#x2F;books&quot;)\npublic class BookController &#123;\n\n    @GetMapping(&quot;&#x2F;&#123;id&#125;&quot;)\n    public String getById(@PathVariable Integer id)&#123;\n        System.out.println(&quot;id &#x3D;&#x3D;&gt; &quot;+id);\n        return &quot;hello , spring boot!&quot;;\n    &#125;\n&#125;\n\n\n\n SpringBoot 程序如何修改呢？SpringBoot 提供了多种属性配置方式,加载顺序由上往下,因而如下三文件,最终:server:port:82\n今后统一使用application.yml\n\napplication.properties\nserver.port&#x3D;80\n\napplication.yml\nserver:\n\tport: 81\n\napplication.yaml\nserver:\n\tport: 82\n\n\n\n\n\n\n\n\n\n\n&#x3D;&#x3D;注意：SpringBoot 程序的配置文件名必须是 application ，只是后缀名不同而已。&#x3D;&#x3D;\n\n\nmybatis\n\nmybatis-plus真的能省很多力,但老师已经用了mybatis了,那算了!\n\n\n\n\n\n\n\n\n\nmybatis也有了自动代码生成器(毕竟国外uu们不使用mp(mybatis-plus),用不到这么好的代码生成器[笑]),老师就用了,参照:\nMyBatis代码自动生成器Mybatis-Generator使用教程\n核心:\n1.mybatis-generator.xml文件(文章中为mybatis-generator-cfg.xml,老师项目中为:mybatis-generator.xml)\n2.pom里面添加mybatis-generator的plugin配置。加载plugins\n3.添加运行配置、运行文件（对了记得吧application.properties后缀改为yml\n\n3是为了使用maven运行maven插件 mybatis-generator:generate -e指令\n注意:不需要担心  自写mapper(xml文件)代码被覆盖, 高于mybatis1.3.7的版本都不会覆盖 ,参见自写mapper(xml文件)代码被覆盖\n\n必须尽快弄好,或者想别的方法让单老师先开始!\n\n新建springboot+mybatis项目(pom)(此时pom插件已经配好)\n新建bean,entity,dao–&gt;mapper自动生成–&gt;controller(老师为了实现登录,使用了一些别的插件)\n不需要配置跨域请求(来自不同端口的请求)(没有使用vue,vue是动态应用,而我们目前页面是static!请求来自同一端口!)\n过程中,application.yml文件配置(项目配置,mysql配置,mybatis的数据源),mybatis-generator文件配置\n不断添加插件,不断添加pom.xml\n\n\n(都在mybatis-generator.xml中配置完成,且生成连带实体类!!!)\n\nUnknown system variable ‘query_cache_size‘ 的解决方法 方法二亲测有效!\n当前,需要解决映射不成功的问题(mybatis理解不深!),以箭头为 映射成功的标志\n\n了解mybatis映射机制,正常来说,不需要mybatis-generator.xml也能生成箭头(视箭头为映射成功的标志)\n\n\n\n\n\n\n\n\n\n尝试,更改mybatis-generator.xml的dao目录(覆盖也没关系!)\n依旧没问题\n映射机制:\n1.引入mybatis依赖(pom.xml)\n2.property.yml文件,配置mybatis映射关系(如果)\n\n\n\n\n使用mybatis-generator.xml生成的都有箭头\n\n\n\n\n\n\n\n\n\n必然不是spring配置错误,而是mybatis理解不深刻!\n尝试:删除某一文件,重配!\n依旧没问题\n\n\n批量注入过程中,发现@Repository改为使用@Mapper注入成功了!\n\n\n\n\n\n\n\n\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-xBg2o0NB-1656345257363)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220626155525255.png)\no.s.s.s.TaskUtils$LoggingErrorHandler    : Unexpected error occurred in scheduled task.\njava.lang.NoClassDefFoundError: com&#x2F;alibaba&#x2F;fastjson&#x2F;util&#x2F;IdentityHashMap\nMaven中的scope总结\n\n\n\n\n\n\n\n\n\n\ncompile不声明scope元素的情况下的默认值；compile表示被依赖包需要参与当前项目的编译，包括后续的测试，运行周期也参与其中，是一个比较强的依赖；打包的时候通常需要包含进去。\n…..\n\nruntimeruntime与compile比较相似，区别在于runtime 跳过了编译阶段，打包的时候通常需要包含进去。\n…..\n\nimportimport 只能在pom文件的中使用，从而引入其他的pom文件中引入依赖，如：在Spring boot 项目的POM文件中，我们可以通过在POM文件中继承 Spring-boot-starter-parent来引用Srping boot默认依赖的jar包\n….\n\n\n因而,也难怪,之前依赖使用import出现了不生效的情况!\n\n\n分析:\n当前版本:较为合理,pom中的依赖是,结合:老师原项目+nacos-discover示例项目得到的(虽说去除了哥的那几个依赖,这是我最担心的!如果出现相关报错,将删除哥的文件)\n\nfastjson找不到:\n\n\n\n\n\n\n\n\n\n依赖冲突:\n当前fastjson版本无问题!2.1依然足矣!\n搜:\n1.External Libraries中并未发现相关依赖的Jar包–&gt;有,非\n\n\n\n\n必然是某些配置错误,因此,进行了配置文件置零操作,与老师当初保持一致(现下所处阶段:不如张俊杰当初,但他引入了大量不靠谱依赖,我这靠谱)\n\n\n\n\n\n\n\n\n\n\nspring-boot-starter-web 版本 不一致,有风险!(低于)\n\n\n\n\n\nnacos配置中心（cloud-alibaba）\n配置管理的必要性:\n\n\n\n\n\n\n\n\n\n同一份程序在不同的环境（开发，测试，生产）、不同的集群（如不同的数据中心）经常需要有不同的 \n配置，所以需要有完善的环境、集群配置管理\n在微服务架构中，当系统从一个单体应用，被拆分成分布式系统上一个个服务节点后，配置文件也必须跟着迁移 \n（分割），这样配置就分散了，不仅如此，分散中还包含着冗余，如下图：\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Lp7d1a0R-1656345257365)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627173947910.png)\n配置中心的服务流程如下： \n1、用户在配置中心更新配置信息。 \n2、服务A和服务B及时得到配置更新通知，从配置中心获取配置。 \n总得来说，配置中心就是一种统一管理各种应用配置的基础服务组件。 \n在系统架构中，配置中心是整个微服务基础架构体系中的一个组件，如下图，它的功能看上去并不起眼，无非就是 \n配置的管理和存取，但它是整个微服务架构中不可或缺的一环。 \n总而言之，在传统巨型单体应用纷纷转向细粒度微服务架构的历史进程中，配置中心是微服务化不可缺少的一个系 \n统组件，在这种背景下中心化的配置服务即配置中心应运而生\n通过配置中心,我们实现了:\n\n合格的配置中心需要满足如下特性： \n配置项容易读取和修改 \n分布式环境下应用配置的可管理性，即提供远程管理配置的能力 \n支持对配置的修改的检视以把控风险 \n可以查看配置修改的历史记录 \n不同部署环境下应用配置的隔离性\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-4f1Y4G9C-1656345257366)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627173914565.png)\n\n问:nacos配置中心的配置是动态的,我们的微服务已经跑起来后,是如何派上用场的?懂了,只是集中管理,但是需要:重新跑!\t\n示例服务中,配置只是进行打印,如何 将配置派上用场?\n\n一般来说，spring boot的配置将在application.yml(也可以是application.properties)文件中编写， \n由于使用外部 配置中心，必须将原先的application.yml重命名为bootstrap.yml，bootstrap.yml如下所示： \nspring.cloud.nacos.confifig.server-addr 指定了Nacos Server的网络地址和端口号\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-uMr6Bfog-1656345257367)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627174121228.png)\n如此,外部(nacos)配置中心派上了用场\n\n通过自定义扩展的 Data Id 配置，既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个配置文件\n\n结论:实现简单,后期可以整,暂时没必要!!!\n\nnacos服务发现\n\n\n\n\n\n\n\n\n笔记摘自:黑马程序员 nacos-服务发现.pdf\n负载均衡,引入 服务发现的目的先导: Spring Cloud服务协作流程:\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-E4rTyo5f-1656345257368)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627183219988.png)\n（1）在微服务启动时，会向服务发现中心上报自身实例信息，这里ServiceB 包含多个实例。 \n每个实例包括：\nIP地址、端口号信息。\n北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090（2）微服务会定期从Nacos Server(服务发现中心)获取服务实例列表。 \n（3）当ServiceA调用ServiceB时，ribbon组件从本地服务实例列表中查找ServiceB的实例，如获取了多个实例如 \nInstance1、Instance2。这时ribbon会通过用户所配置的负载均衡策略从中选择一个实例。 \n（4）最终，Feign组件会通过ribbon选取的实例发送http请求。 \n采用Feign+Ribbon的整合方式，是由Feign完成远程调用的整个流程。而Feign集成了Ribbon，Feign使用Ribbon \n完成调用实例的负载均衡。 \n考察核心:光凭zuul网关配置,能否实现负载均衡?(而非在 service微服务互相调用过程中,通过feign实现!)\n(负载均衡的两个环节:1.通过feign(调用ribbon组件)微服务直接互相调用(客户端负载均衡,微服务是nacos客户端  nacos server是服务端)   2.通过zuul 网关配置,端口转发(服务端负载均衡,通过nginx实现的一样是服务端负载均衡;zuul和nginx往往是一起使用的!)  )\n\n\n\n\n\n\n\n\n\nribbon根据负载均衡策略负责选择示例,feign会通过ribbon来选择实例进而发送请求(feign集成来ribbon)\n(本文档,似乎一直在集中阐述 客户端负载均衡!)\n\n没有nacos服务注册中心时,微服务调用\n\n\n\n\n\n\n\n\n在微服务架构中,如果没有nacos服务注册中心,如何进行微服务之间互相调用(通信)?\nService B暴露接口供Service A调用:\n@SpringBootApplication \n@RestController \npublic class SpringRestProviderBootstrap &#123; \n    public static void main(String[] args) &#123; \n        SpringApplication.run(SpringRestProviderBootstrap.class, args); \n    &#125;\n    \n@GetMapping(value &#x3D; &quot;&#x2F;service&quot;) &#x2F;&#x2F;暴露服务 \npublic String service()&#123; \n    return &quot;provider invoke&quot;; \n&#125; \n&#125;\n\n\n\n配置文件:\nserver.port &#x3D; 56010\n\n\n\nService A去调用Service B\n@SpringBootApplication \n@RestController \npublic class SpringRestConsumerBootstrap \n&#123; public static void main(String[] args) &#123;\n    SpringApplication.run(SpringRestConsumerBootstrap.class, args); \n&#125;\n \n@Value(&quot;$&#123;provider.address&#125;&quot;) \nprivate String providerAddress; \n \n@GetMapping(value &#x3D; &quot;&#x2F;service&quot;) \npublic String service()&#123; \n    RestTemplate restTemplate &#x3D; new RestTemplate(); &#x2F;&#x2F;调用服务 \n    String providerResult &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;&quot; + providerAddress + \t\t\t\t   &quot;&#x2F;service&quot;,String.class); return &quot;consumer invoke | &quot; + providerResult; \n&#125; \n&#125;\n\n\n\nRestTemplate工具类,spring提供的一个HTTP请求工具\n\n\n\n\n\n\n\n\n\n在服务的调用过程中，使用到了一个工具，叫做 RestTemplate，RestTemplate 是由 Spring 提供的一个 HTTP 请求工具。在上文的案例中，开发者也可以不使用 RestTemplate ，使用 Java 自带的 HttpUrlConnection 或者经典的网络访问框架 HttpClient 也可以完成上文的案例，只是在 Spring 项目中，使用 RestTemplate 显然更方便一些。在传统的项目架构中，因为不涉及到服务之间的调用，大家对 RestTemplate 的使用可能比较少\n总结:\n\n\n\n\n\n\n\n\n\n关键: application.yml中配置provider.address属性,拼凑出地址后,使用restTemplate.getForObject方法进行调用!\n但是,微服务可能是部署在云环境的，服务实例的网络位置或许是动态分配的。另外，每一个服务一般会有多个实 \n例来做负载均衡，由于宕机或升级，服务实例网络地址会经常动态改变。再者，每一个服务也可能应对临时访问压 \n力增加新的服务节点。正如下图所示:\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pK72PVE8-1656345257369)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627192149824.png)\n\nnacos服务注册的实现(服务发现(让服务之间互相感知)与管理问题)\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9PJda5TR-1656345257369)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627192235974.png)\n\n\n\n\n\n\n\n\n\n（1）在每个服务启动时会向服务发现中心上报自己的网络位置。这样，在服务发现中心内部会形成一个服务注册 \n表，服务注册表是服务发现的核心部分，是包含所有服务实例的网络地址的数据库。 \n（2）服务发现客户端会定期从服务发现中心同步服务注册表 ，并缓存在客户端。 \n（3）当需要对某服务进行请求时，服务实例通过该注册表，定位目标服务网络地址。若目标服务存在多个网络地 \n址，则使用负载均衡算法从多个服务实例中选择出一个，然后发出请求。 \n总结一下，在微服务环境中，由于服务运行实例的网络地址是不断动态变化的，服务实例数量的动态变化 ，因此无 \n法使用固定的配置文件来记录服务提供方的网络地址，必须使用动态的服务发现机制用于实现微服务间的相互感 \n知。各服务实例会上报自己的网络地址，这样服务中心就形成了一个完整的服务注册表，各服务实例会通过服务发 \n现中心来获取访问目标服务的网络地址，从而实现服务发现的机制。\n服务注册的实现极其简单:\n(下面这个例子是从 海马程序员-服务发现中,摘出来的部分代码,像@EnableFeignClients如果仅为实现服务注册而不实现feign调用其他微服务,那它是多余的)\n(为了更深刻理解,看源文档  nacos-服务发现.pdf (文档视频中有,我的博客中也有) or 黑马nacos-服务发现 视频)\n\napplication.yml配置 \nserver: \n\tport: 56020 #启动端口 命令行注入 \n\t\nspring: \n\tapplication: \n\t\tname: quickstart‐consumer \n\tcloud: \n\t\tnacos: \n\t\t\tdiscovery: \n\t\t\t\tserver‐addr: 127.0.0.1:8848\n\n2.Provider(生产者)远程代理定义\n\n\n@SpringBootApplication \n@EnableDiscoveryClient \n@EnableFeignClients #开启FeignClient,如果只是实现服务注册,不使用feign调用其他微服务的话,就没必要了\npublic class NacosConsumerApp &#123; \n    public static void main(String[] args) &#123; \n        SpringApplication.run(NacosConsumerApp.class, args); \n    &#125; \n&#125;\n\n\n\n\n\n\n\n\n\n\nNote: @EnableDiscoveryClient 在spring cloud项目中表明此项目是一个注册发现客户端，这里注册服务发 \n现使用的是Nacos \nNote: @EnableFeignClients 开启FeignClient\n&#x3D;&#x3D;可以说,实现服务注册,只需要: @EnableDiscoveryClient 就行!!!&#x3D;&#x3D;\n\n有了nacos服务注册中心时,利用feign(ribbon)进行微服务调用spring(boot)使用feign需在pom.xml中加入依赖:\n&lt;dependency&gt; \n\t&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt; \n\t&lt;artifactId&gt;spring‐cloud‐starter‐openfeign&lt;&#x2F;artifactId&gt; \n&lt;&#x2F;dependency&gt;\n\n\n\n参考前面 没有nacos服务注册中心时,微服务调用 的ServiceA调用ServiceB的例子，我们有了 在服务注册后 使用Feign实现这个过程，代码如下： \nService B暴露”&#x2F;service”服务端点，如下：\n@SpringBootApplication \n@RestController\npublic class SpringRestProviderBootstrap &#123; \n    public static void main(String[] args) \n    &#123; \n        SpringApplication.run(SpringRestProviderBootstrap.class, args); \n    &#125;\n@GetMapping(value &#x3D; &quot;&#x2F;service&quot;) \n\n&#x2F;&#x2F;暴露服务 \npublic String service()&#123; return &quot;provider invoke&quot;; &#125; &#125;\n\n\n\nService A中,通过Feign调用Service B方式如下： \n（1）声明Feign客户端 \n@FeignClient(value &#x3D; &quot;serviceB&quot;) \npublic interface ServiceBAgent &#123; \n\n    &#x2F;** \n    * 根据用户名查询账号信息 \n    * @param username 用户名 \n    * @return 账号信息 \n    *&#x2F; \n&#x2F;&#x2F;Feign英文表意为“假装，伪装，变形”，此处正是将HTTP报文请求方式 伪装为简单的java接口(内部,未通过TTTP)调用方式\n@GetMapping(value &#x3D; &quot;&#x2F;service&quot;) \npublic String service(); &#125;\n\n\n\n\n\n\n\n\n\n\nFeign是Netflflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。Feign \n的英文表意为“假装，伪装，变形”， 可以理解为将HTTP报文请求方式伪装为简单的java接口调用方式。\n（2）业务调用\n@Autowired \nprivate ServiceBAgent serviceBAgent.; \n&#x2F;&#x2F;....略 \nserviceBAgent.service();\n&#x2F;&#x2F;....略\n\n\n在 声明Feign客户端 之后，Feign会根据**@FeignClient注解使用java的动态代理技术生成代理类**，在这里我们\n\n指定@FeignClient value为serviceB，则说明这个类的远程目标为spring cloud的服务名称为serviceB的微服 \n务。\n\nserviceB的具体访问地址，Feign会交由ribbon获取，若该服务有多个实例地址，ribbon会采用指定的负载均 \n衡策略选取实例。 (Feign默认集成了Ribbon，可以直接使用)\n\n\n\n\n\n\n\n\n\n可通过下面方式在spring boot 配置文件中修改默认的负载均衡策略： \naccount‐service.ribbon.NFLoadBalancerRuleClassName&#x3D;com.netflix.loadbalancer.RandomRule\n\naccount-service 是调用的服务的名称，后面的组成部分是固定的。\n\nFeign兼容spring的web注解（如：@GetMapping），它会分析声明Feign客户端方法中的Spring注解，得出 \nHttp请求method、参数信息以及返回信息结构。 \n\n当业务调用Feign客户端方法时，会调用代理类，根据以上分析结果，由代理类完成实际的参数封装、远程 \nhttp请求，返回结果封装等操作。\n\n\n\n\n综合架构演示:\n\n\n\n\n\n\n\n\n\n\n由于Feign是基于Http Restful的调用，在高并发下的性能不够理想，我们将RPC方案从feign切换为Dubbo, 将Spring Cloud与阿里系的若干组件完美集成()\n系统架构图:\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i5hEqqxd-1656345257370)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627201408150.png)\n\nservice-api的作用:\n\n\n\n\n\n\n\n\n\n 优劣:\n 取舍:\n\nService2配置(纯生产者):\n\n\n\n\n\n\n\n\n\n package com.itheima.microservice.service2.service; \n@org.apache.dubbo.config.annotation.Service \npublic class ProviderServiceImpl implements ProviderService &#123; \n @Override \n public String service() &#123; \n     return &quot;Provider invoke&quot;; \n &#125; \n&#125;\n\n 其中， @org.apache.dubbo.config.annotation.Service 是 Dubbo 服务注解，仅声明该 Java 服务（本地）实现 \n 为 Dubbo 服务。 因此，下一步需要将其配置 Dubbo 服务（远程）。\n 配置 Dubbo 服务 \n 在暴露 Dubbo 服务方面，推荐开发人员外部化配置的方式，即指定 Java 服务实现类的扫描基准包。\n Dubbo Spring Cloud 继承了 Dubbo Spring Boot 的外部化配置特性，也可以通过标注 @DubboComponentScan 来实现基准包扫描。 \n 同时，Dubbo 远程服务需要暴露网络端口，并设定通讯协议，完整的 YAML 配置如下所示:\n server: port: $&#123;port:56040&#125; #启动端口 命令行注入 \nspring: application: \n\tname: service2 \n\tmain: \n\t\tallow‐bean‐definition‐overriding: true # Spring Boot 2.1 需要设定 \n\tcloud: \n\t\tnacos: \n\t\t\tdiscovery: \n\t\t\t\tserver‐addr: 127.0.0.1:8848 \n\t\t\t\tnamespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 \n\t\t\t\tcluster‐name: DEFAULT \n\t\t\tconfig: server‐addr: 127.0.0.1:8848 # 配置中心地址 \n\t\t\t\tfile‐extension: yaml \n\t\t\t\tnamespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 # 开发环境 \n\t\t\t\tgroup: NACOS_MICROSERVICE_GROUP # xx业务组 \n\t\t\t\tdubbo: \n\t\t\t\t\tscan: # dubbo 服务扫描基准包 \n\t\t\t\t\tbase‐packages: com.itheima.microservice protocol: # dubbo 协议 \n\t\t\t\t\tname: dubbo # dubbo 协议端口（ ‐1 表示自增端口，从 20880 开始） \n\t\t\t\t\tport: $&#123;dubbo_port:20891&#125; \n\t\t\tregistry: \n\t\t\t\taddress: nacos:&#x2F;&#x2F;127.0.0.1:8848 \n\t\t\tapplication: \n\t\t\t\tqos‐enable: false \n\t\t\tconsumer: \n\t\t\t\tcheck: false\n\n 核心:\n 标注 @DubboComponentScan 来实现基准包扫描;Dubbo 远程服务需要暴露网络端口\n\ndubbo.scan.base-packages : 指定 Dubbo 服务实现类的扫描基准包，将@org.apache.dubbo.confifig.annotation.Service注解标注的service暴露为dubbo服务\n\ndubbo.protocol : Dubbo 服务暴露的协议配置，其中子属性 name 为协议名称， port 为dubbo协议端口 可以指定多协议，如：dubbo.protocol.rmi.port&#x3D;1099 \n\ndubbo.registry : Dubbo 服务注册中心配置，其中子属性 address 的值 “nacos:&#x2F;&#x2F;127.0.0.1:8848”，说明dubbo服务注册到nacos ,相当于原生dubbo的xml配置中的 &lt;dubbo:registry address&#x3D;”10.20.153.10:9090” &#x2F;&gt;\n\n\n 启动服务提供方应用 \n Dubbo Spring Cloud 引导类与普通 Spring Cloud 应用并无差别，如下所示： \n @SpringBootApplication \n@EnableDiscoveryClient \npublic class Service2Bootstrap &#123; \n\tpublic static void main(String[] args) &#123; \n       SpringApplication.run(Service2Bootstrap.class, args); \n   &#125;\n&#125;\n\nService1配置(生产者&amp;消费者):\n\n\n\n\n\n\n\n\n\n实现dubbo服务\npackage com.itheima.microservice.service1.service; \n@org.apache.dubbo.config.annotation.Service  \n&#x2F;&#x2F;能替换成 import org.apache.dubbo.config.annotation   @Service\npublic class ConsumerServiceImpl implements ConsumerService &#123; \n @Override\n public String service() &#123; \n     return &quot;Consumer invoke &quot; ; \n &#125; \n&#125;\n\n使用@org.apache.dubbo.confifig.annotation.Service标记dubbo服务 \nbootstrap.yml配置文件与Service2一致\npom.xml引入 spring-cloud-starter-dubbo依赖，它会根据接口生成代理对象\n&lt;dependency&gt; \n\t&lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt; \n\t&lt;artifactId&gt;spring‐cloud‐starter‐dubbo&lt;&#x2F;artifactId&gt; \n&lt;&#x2F;dependency&gt;\n\n\n\n实现Service1调用Service2\n@org.apache.dubbo.config.annotation.Service \npublic class ConsumerServiceImpl implements ConsumerService &#123; \n @Reference \n ProviderService providerService; \n public String service() &#123; \n     return &quot;Consumer invoke | &quot;+providerService.service(); \n &#125; \n&#125;\n\n关键:\n使用@Reference 注入 代理对象! (引入的dubbo依赖只在此处使用,引导类处不会像feign的使用一样有@EnableFeignClients注释)\nDubbo Spring Cloud 引导类与普通 Spring Cloud 应用并无差别(引导类处不会像feign的使用一样有@EnableFeignClients注释)\n\nApplication1配置:\n\n\n\n\n\n\n\n\n\n   实现 application1调用Service1\n   @RestController \npublic class Application1Controller &#123; \n @org.apache.dubbo.config.annotation.Reference \n private ConsumerService consumerService; \n\n @GetMapping(&quot;&#x2F;service&quot;) \n public String service()&#123; \n     return &quot;test&quot; + consumerService.service(); \n &#125; \n&#125;\n\n   测试：  请求：http://localhost:56020/application1/service  \n   consumerService正常生成代理对象，service1被调用。 \n\nzuul配置:\n\n\n\n\n\n\n\n\n\n 原来的单体架构，所有的服务都是本地的，UI可以直接调用，现在按功能拆分成独立的服务，跑在独立的一般都在 \n 独立的虚拟机上的 Java进程了。客户端UI如何访问？他的后台有N个服务，前台就需要记住管理N个服务，一个服 \n 务下线&#x2F;更新&#x2F;升级，前台就要重新部署，这明显不服务我们拆分的理念，特别当前台是移动应用的时候，通常业务 \n 变化的节奏更快。另外，N个小服务的调用也是一个不小的网络开销。\n [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VujOFLBE-1656345257371)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627233329623.png)\n\nZuul网关的作用:\n\n提供统一服务入口，让微服务对前台透明 \n\n聚合后台的服务，节省流量，提升性能 \n\n提供安全，过滤，流控等API管理功能\n\n\n\nSpring Cloud Zuul是整合Netflflix公司的Zuul开源项目实现的微服务网关，它实现了请求路由、负载均衡、校验过 \n虑等 功能。 \n\nZuul与Nginx怎么配合使用？\n\n Zuul与Nginx在实际项目中需要配合使用，如下图，Nginx的作用是反向代理、负载均衡，Zuul的作用是保障微服 \n 务的安全访问，拦截微服务请求，校验合法性及负载均衡。\n  [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hKW870pZ-1656345257372)(SSM(含springboot)]+Maven高级+Mybatis.assets&#x2F;image-20220627233539020.png)\n api-gateway配置\n server: \n\tport: 56010 #启动端口 命令行注入 \nspring: \n\tapplication: \n\t\tname: api‐gateway \n\tmain: \n\t\tallow‐bean‐definition‐overriding: true # Spring Boot 2.1 需要设定 \n\tcloud: \n\t\tnacos: \n\t\t\tdiscovery: \n\t\t\t\tserver‐addr: 127.0.0.1:8848 \n\t\t\t\tnamespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 \n\t\t\t\tcluster‐name: DEFAULT \n\t\t\tconfig: \n\t\t\t\tserver‐addr: 127.0.0.1:8848 # 配置中心地址 \n\t\t\t\tfile‐extension: yaml \n\t\t\t\tnamespace: c67e4a97‐a698‐4d6d‐9bb1‐cfac5f5b51c4 # 开发环境 \n\t\t\t\tgroup: NACOS_MICROSERVICE_GROUP # xx业务组\n\n 网关的路由配置采用nacos远程配置，在nacos控制台开发环境中新增api-gateway.yaml配置集，配置组为 \n TEST_GROUP，配置内容如下： \n zuul: \n\troutes: \n\t\tapplication1: \n\t\t\tstripPrefix: false \n\t\t\tpath: &#x2F;application1&#x2F;**\n\n 将请求为 &#x2F;application1&#x2F; 开头的请求路由至 application1 服务，保留请求url中的 &#x2F;application1&#x2F; \n api-gateway启动:\n 注意在启动类上使用@EnableZuulProxy注解标识此工程为Zuul网关，启动类代码如下:\n @SpringBootApplication \n@EnableDiscoveryClient \n@EnableZuulProxy \npublic class ApiGatewayBootstrap &#123; \n   public static void main(String[] args) &#123; \n       SpringApplication.run(ApiGatewayBootstrap.class, args); \n   &#125; \n&#125;\n\n 浏览器访问: http://127.0.0.1:56010/application1/service (相当于UI 前端 get请求)\n 通过网关（api-gateway）请求Application1应用，Application1的业务实现又贯穿service1、service2\n\n\n\n使用@org.apache.dubbo.confifig.annotation.Service标记dubbo服务\n\n杂记:\n\n\n\n\n\n\n\n\n\n浏览器中输入:\nhttp://127.0.0.1:56020/service\n相当于前端发送get请求,请求地址(url)为:http://127.0.0.1:56020/service,即 服务器:http://127.0.0.1 端口:56020  的service后端接口\n但是,还是postman好用,能够发出post请求\n","slug":"黑马程序员ssm总结","date":"2022-10-06T13:21:00.000Z","categories_index":"","tags_index":"ssm,spring,springboot,maven,mvc,micro-service,gateway,zuul,nacos,feign,ribbon,dubbo,Service Register","author_index":"Statck"},{"id":"549e004de501d99e71ac8ff6ee79ef89","title":"redis总结","content":"这是testPage\n&#x3D;&#x3D;redis有注释 与 编程&#x3D;&#x3D;两种实现方式–找术语!\ntitle1conten1\ntitle11content2\n\ndsf\ndsfsd\ndfs\ndsf\n\ntitle 2\n dsf\n dfs\n sdf\n \n\n\n当前,图片是主要问题\n特殊的自定义标签,暂时没有使用必要(为文章的搬运带来麻烦,使用基础功能即可)–局部调优\n\n进行试验\n实际搬运\n\n\n\n","slug":"redis总结","date":"2022-10-06T01:10:10.000Z","categories_index":"","tags_index":"spring,redis,后台,总结,后端,redis","author_index":"Statck"}]