{"title":"算法与算法分析","uid":"22d07ecd45c156a834bf0fe1d926426e","slug":"算法与算法分析","date":"2025-06-10T08:00:00.000Z","updated":"2025-06-10T08:58:00.863Z","comments":true,"path":"api/articles/算法与算法分析.json","keywords":null,"cover":[],"content":"<p>这是 研一-王玮-算法与算法分析 课程的 简要复习笔记.</p>\n<p>时间复杂度符号:</p>\n<p>T(n)</p>\n<p><strong>大O符号（Ο）</strong>，读作”big-oh”，表示函数的上界，用于描述算法的最坏情况性能。例如，如果一个算法的时间复杂度为O(n^2)，则意味着在最坏情况下，算法的执行时间不会超过n^2的某个常数倍<a href=\"https://blog.csdn.net/anshuai_aw1/article/details/108449000\">1</a>。</p>\n<p><strong>大Ω符号（Ω）</strong>，读作”big omega”，表示函数的下界，用于描述算法的最佳情况性能。例如，Ω(n)表示算法在最佳情况下至少需要执行n次操作<a href=\"https://blog.csdn.net/anshuai_aw1/article/details/108449000\">1</a>。</p>\n<p><strong>大θ符号（Θ）</strong>，读作”theta”，表示函数的确界，即同时是上界和下界。如果一个算法的时间复杂度为Θ(n)，则表示算法的性能紧密地围绕着线性增长<a href=\"https://blog.csdn.net/anshuai_aw1/article/details/108449000\">1</a>。</p>\n<p><strong>小o符号（ο）</strong>，读作”small-oh”，表示函数的严格上界，用于描述算法性能的上限，但不包括该界限本身。例如，o(n^2)表示算法的性能增长率小于n^2<a href=\"https://blog.csdn.net/qq_41976613/article/details/105026946\">2</a>。</p>\n<p><strong>小ω符号（ω）</strong>，读作”small omega”，表示函数的严格下界，用于描述算法性能的下限，但不包括该界限本身。例如，ω(n)表示算法的性能增长率大于n<a href=\"https://blog.csdn.net/qq_41976613/article/details/105026946\">2</a>。</p>\n<h3 id=\"作业要求\"><a href=\"#作业要求\" class=\"headerlink\" title=\"作业要求\"></a>作业要求</h3><p><img src=\"/./%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.assets/image-20250331155333628.png\" alt=\"image-20250331155333628\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nkcsfile@163.com\n实验提交内容\n-源程序、可执行程序、实验报告(实验内容算法设计思想、程序运行的输入、输出截图,核心代码及说明。)\n实验提交方式\n一将上述提交内容压缩，以“作业x+学号+姓名&quot;的方式提交至邮箱:nkcsfile@163.com把末统一压缩提交。</code></pre>\n\n\n\n\n\n<hr>\n<h1 id=\"知识复习\"><a href=\"#知识复习\" class=\"headerlink\" title=\"知识复习\"></a>知识复习</h1><h3 id=\"overview\"><a href=\"#overview\" class=\"headerlink\" title=\"overview\"></a>overview</h3><p>平时分 40分。期末60分。期末总分100，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">10*2（选择题10道） + 15*4 (大题4道) + 简单题20&#x3D;100分.\n大题 四道,尤其 注意 动规dp + 分支限界.</code></pre>\n\n\n\n<p>期末 至少33分才能及格。而 贪心 +动规dp+分支限界，又占了占期末60%-70%的分数</p>\n<p>基础一章:算法与算法分析</p>\n<p>水课三章:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">分治技术:二分排序 归并搜索 快速排序 矩阵乘法\n搜索算法(回溯法):折半搜索 二叉搜索 Hashing技术(n次开放寻址) 图的bfs dfs . 引例:迷宫问题,N皇后问题. + 启发式方法示例(A,A*解决八数码问题)\n贪心技术:最小生成树 哈夫曼编码 单源最短路径（Dijkstra）算法只能求解单源最短路径问题，即从一个指定的源顶点到其他所有顶点的最短路径。如果需要求解所有顶点对之间的最短路径，可以使用Floyd-Warshall算法。 【活动安排问题】\n\n\n\n-----\n\n-----\n分治：\n求最大&#x2F;最小值\n二分搜索 合并排序 快速排序\n最近点问题\n矩阵乘法之STRASSEN\n\n课堂作业1:--&gt;单点突破!\n设计一个满足以下要求的循环比赛日程表：\n(1)每个选手必须与其他n-1个选手各赛一次；\n(2)每个选手一天只能赛一次；\n(3)循环赛一共进行n-1天。\n\n要求：\n（1）描述设计思想\n（2）给出n&#x3D;8时的比赛日程表\n----\n搜索算法:【重点设计 OPEN表，CLOSE表，拓展节点. 重点在于:回溯法(DFS) 及 其启发式改进.穷举+剪枝】\n折半搜索 二叉搜索 Hashing技术(n次开放寻址) 图的bfs dfs . 引例:迷宫问题,N皇后问题. + 启发式方法示例(A,A*解决八数码问题)\n课堂例题:hashing AVL平均搜索长度\n\n随堂练习2:\n已知：以下状态空间图，节点表示状态，边表示无代价状态转移。初始状态为S，目标状态为G,子节点扩展顺序按字母升序（如S的子节点按A→B→C顺序扩展）。忽略重复状态检测（即允许重复扩展同一节点）。\n要求：使用深度优先搜索（DFS），和宽度优先搜索（BFS）记录从S到G的扩展顺序、OPEN表和CLOSED表的变化并写出最终找到的路径\n\n--&gt;单点突破.有截图.\n----\n贪心算法:【相对简单】\n（1）活动安排问题；\n（2）背包问题；(非0-1背包)\n（3）最优装载问题；\n（4）哈夫曼编码；\n（5）单源最短路径；\n（6）最小生成树；\n（7）多机调度问题。--&gt;单点突破\n\n----\n动态规划：【大量的状态转移方程】\n1. 最优路径问题\n2. 资源配置问题\n3.复合系统工作可靠性问题\n4.生产与库存问题机器负荷分配问题--&gt;单点突破\n5. 设备更新问题\n6. 0-1背包问题\n\n随堂练习4:动态规划:\n\n某公司打算在3个不同的地区设置4个销售点，根据市场部门估计，在不同地区设置不同数量的销售点每月可得到的利润如下表所示。试问在各地区如何设置销售点可使每月总利润最大。(参照 工厂 机器负荷分配)\n\n----\n分支限界法：【搜索一章，回溯法问题的再度解决。BFS广度优先+ FIFO队列&#x2F;优先队列分支限界.PT表.在分支限界法中，每一个活结点只有一次机会成为扩展结点。 活结点一旦成为扩展结点，就一次性产生其所有儿子结点。 】\n图问题中的分支限界法\n旅行商问题，即TSP问题（Traveling Salesman Problem）--&gt;单点突破\n多段图的最短路径问题\n0-1背包\n\n组合中的分支限界法：--》不讲了\n任务分配问题\n批处理作业调度问题\n</code></pre>\n\n\n\n<p>回溯法 与 分支限界 对比. 分治法(递归) 与 动态规划(迭代) 对比,</p>\n<h3 id=\"直接做题，自我测评\"><a href=\"#直接做题，自我测评\" class=\"headerlink\" title=\"直接做题，自我测评\"></a>直接做题，自我测评</h3><p>题目1：<a href=\"https://blog.csdn.net/qq_43055855/article/details/143496448\">https://blog.csdn.net/qq_43055855/article/details/143496448</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n\n8.一个问题可用动态规划算法或贪心算法求解的关键特征是问题的（ B ）。\nA．重叠子问题 B．最优子结构性质\nC．贪心选择性质 D．定义最优解\n\n一个问题可用动态规划算法或贪心算法求解的关键特征是问题的最优子结构性质，即问题的最优解包含其子问题的最优解。\n动态规划与贪心算法的关键区别\n特征\t动态规划\t贪心算法\n核心要求\t最优子结构 + 重叠子问题\t最优子结构 + 贪心选择性质\n子问题处理\t存储所有子问题的解（避免重复计算）\t不存储子问题解，仅做当前最优选择\n决策方式\t基于子问题的历史解综合决策\t基于当前状态的局部最优直接决策\n\n重叠子问题：是动态规划优化的前提（如用记忆化搜索减少重复计算），但并非贪心算法的必要条件。\n贪心选择性质：贪心算法的特有要求（即局部最优可导致全局最优），动态规划不要求这一点。\n----\n10.下列算法中通常以自底向上的方式求解最优解的是（ B ）。\nA．备忘录法 B．动态规划法\nC．贪心法 D．回溯法\n\n1. 自底向上与自顶向下的本质区别\n自底向上（迭代）：从最小子问题开始求解，逐步构建更大规模问题的解，无需递归回溯。\n自顶向下（递归 + 记忆化）：从原问题出发，递归分解为子问题，用备忘录存储中间结果避免重复计算。\n2. 各算法的求解方式对比\n算法类型\t求解方式\t典型案例\n动态规划法\t自底向上为主（如填表）\t最长公共子序列、背包问题\n备忘录法\t自顶向下（递归 + 记忆化）\t斐波那契数列的优化求解\n贪心法\t自顶向下（局部最优选择）\t最小生成树、哈夫曼编码\n回溯法\t自顶向下（深度优先搜索 + 回退）\t八皇后问题、迷宫求解\n\n三种方法 求解0-1背包问题 总结：https:&#x2F;&#x2F;www.doubao.com&#x2F;thread&#x2F;w92273109d14beaf9\n回溯法通过【递归和剪枝穷举】可能解，适合小规模场景；\n动态规划法利用【状态转移表存储最优子结构】，适用于容量有限的问题；\n分支限界法以【队列或优先队列扩展节点】，通过【上界剪枝加速】，更适合大规模优化问题。\n三种方法均能求解 0-1 背包问题，但根据问题规模和效率需求选择不同策略。\n\n---\n11.下列算法中不能解决0&#x2F;1背包问题的是（ A ）。\nA．贪心法 B．动态规划\nC．回溯法 D．分支限界法\n\n动态规划：通过二维数组dp[i][j]记录前i个物品在容量j下的最大价值，逐步递推全局最优解。（自底向上）\n回溯法：枚举所有可能的物品组合，通过剪枝优化搜索效率。（自顶向下，dfs or bfs，搜索一章 出现）\n分支限界法：利用优先队列和上界函数，高效剪除非最优分支。(广度优先搜索 + 剪枝，dfs，但根据 节点优先级 进行拓展，时间复杂度依赖上界函数精度，【可能远优于回溯法】。)\n\n三者对比：https:&#x2F;&#x2F;www.doubao.com&#x2F;thread&#x2F;w7ac57db66c3a6aae\n----\n维度\t回溯法\t动态规划\t分支限界法\n搜索策略\t深度优先（递归 + 回退）\t自底向上递推（无搜索过程）\t广度优先（优先队列）\n解的目标\t所有可行解\t全局最优解\t全局最优解\n状态存储\t仅存储当前路径状态\t存储所有子问题解（表格）\t存储当前扩展节点的状态\n剪枝时机\t发现当前路径不可行时剪枝\t无剪枝（子问题必求解）\t节点边界值无法超越最优解时剪枝\n典型场景\t八皇后问题、子集和问题\t0&#x2F;1 背包、最长公共子序列\t旅行商问题、电路板排列问题\n（问题之间，可以其它方法解决；比如 分支限界 也能解决0&#x2F;1背包问题）\n---------\n\n</code></pre>\n\n<p>题目2：<a href=\"https://blog.csdn.net/qq_46373141/article/details/135415593\">https://blog.csdn.net/qq_46373141/article/details/135415593</a></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">4.\n关于回溯法描述正确的是：答案选 D。使用回溯法时可同时用约束函数和上界函数剪去一部分子树，提高求解效率。A 选项，回溯法通常采用深度优先搜索策略，不是也可采用广度优先搜索策略；B 选项，回溯法求解需要事先定义问题的解空间；C 选项，0 - 1 背包问题的解空间树是一颗子集树，不是排列树。\n\n7.\n假如需要计算以下6个矩阵的依次连乘：(最优乘法数?)\n矩阵连乘问题:矩阵乘法满足结合律(尽管不满足 交换律).若A 是p ×q 矩阵，B 是q ×r 矩阵，则A ×B 的代价是pqr.不同的计算次序会导致不同的计算代价，我们要做的就是让这个代价最小。见:https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44952817&#x2F;article&#x2F;details&#x2F;110124596\n\n12.\n动态规划法与分治法的异同\n简述动态规划法与分治法的异同。\n\n标准答案：\n\n两者的共同点是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。（2分）\n两者的不同点如下：\n适合用动态规划法求解的问题，分解得到的各子问题往往不是相互独立的(重叠子问题性质)，而分治法中的子问题相互独立；（3分）\n另外，动态规划法用表保存已求解过的子问题的解，再次碰到同样的子问题时不必重新求解，只需查询答案，故可获得多项式级时间复杂度，效率较高，而分治法中对于每次出现的子问题均求解，导致同样的子问题被反复求解，故产生指数增长的时间复杂度，效率较低。（5分）\n----\n13.简答题-对比说明分支限界法中活结点表的两种组织形式及其特点。\n对比说明分支限界法中活结点表的两种组织形式及其特点。\n\n标准答案：\n\n从活结点表中选择下一扩展结点的不同方式导致不同的分支限界法，最常见的有以下两种方式：\n\n1）队列式（FIFO）分支限界法\n\n队列式分支限界法将活结点组织成一个队列，并按队列的先进先出FIFO(First In First Out)原则选取下一个结点为当前扩展结点。【5分】\n\n2）优先队列式分支限界法\n\n优先队列式分支限界法将活结点组织成一个优先队列，并按优先队列中规定的结点优先级选取下一个结点为当前扩展结点。【5分】\n\n---\n</code></pre>\n\n<p>题目3：<a href=\"https://wenku.baidu.com/aggs/adef5473f242336c1eb95ec2.html?_wkts_=1749448730839\">https://wenku.baidu.com/aggs/adef5473f242336c1eb95ec2.html?_wkts_=1749448730839</a></p>\n<h3 id=\"基础一章-算法与算法分析\"><a href=\"#基础一章-算法与算法分析\" class=\"headerlink\" title=\"基础一章:算法与算法分析\"></a>基础一章:算法与算法分析</h3><p>1.疑问</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">一个算法就是为解一个问题或实现某一目标的逐步过程,有限步骤内解一个数学问题的过程,\n有穷规则的集合\n· 有穷性：一个算法必须总是在执行有穷步之后结束；\n· 确定性：算法的每一步骤，必须是确切地定义的；组成算法的 每条【指令】是清晰的，无歧义的。\n· 输入：有0或多个输入值；\n· 输出：有1或多个输出值；\n· 可行性：算法中要做的运算都是相当基本的，能够精确地进行的。\n\n实例特征说明：\n1.指令空间：与实例特征无关的常数\n2.[重点]数据空间：\n- 常量和简单变量-实例无关\n- 复合变量(数组、链表、树和图等) --问题实例特征有关\n- 动态空间分配—实例特征有关\n3.环境栈空间(函数调用)-是否递归?\n- 非递归：实例特征无关\n- 递归：实例特征相关\n递归栈空间包括递归深度（即嵌套递归调用的最大层次）、局部变量和形参的空间。\n\n---\n空间复杂性S(n)。\n时间复杂性T(n)；\nn是问题的规模（输入大小，实例特征相关）\n\nS(P)&#x3D;c + S_p(实例特征)\n\n在使用操作计数时，我们把精力集中在关键的操作上，而忽略其它操作。执行步数的方法则试图通过关注所有的操作以便克服操作计数的不足，然而，执行步数的概念[本身就不精确]。所以操作计数和程序步数[都不能够精确地描述时间复杂性]。\n---\n更精准的表述-渐进表示:\n1.渐近紧确界记号：Θ （big-theta） 相当于&quot;&#x3D;&quot;\n2.渐近上界记号 ：O (big-oh) 相当于&quot;&lt;&#x3D;&quot;\n3.渐近下界记号 ：Ω (big-omega) 相当于&quot;&gt;&#x3D;&quot;\n\n4.非渐近紧确上界：o(小-oh) 相当于&quot;&lt;&quot;\n5.非渐近紧确下界：ω(小-omega) 相当于&quot;&gt;&quot;\n6.渐近记号Θ、Ο、o、Ω、ω关系\n\n原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;so_geili&#x2F;article&#x2F;details&#x2F;53353593\n\n---\n栈（LIFO）\n\n队列（FIFO）\n\n---\n\n散列表(哈希表),出现冲突 碰撞时:\n1.开放地址法(线性 二次 随机)\n2. 链地址法\n3. 差值解决法(再哈希法?)\n4. 分桶杂凑法\n\n\n\n  最长公共子序列、投资问题（填表）、贪心算法、编辑距离（最好会填表，我觉得填表还是比较容易的，可以去B站搜一下填表的视频）、分支限界法求解背包问题\n  \n  </code></pre>\n\n\n\n<p>2.优先队列 求解:?</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">最大堆、堆排序；\n最大高度优先左高树；\n哈夫曼编码。\n</code></pre>\n\n\n\n<p>3.树</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">二叉搜索树\nAVL搜索树(平衡二叉搜索树)\nB树(平衡多路查找树)\n</code></pre>\n\n<p>4.图</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">BFS(队列)\nDFS(栈)\n\n最小生成树\n（Kruskal、Prim）\n</code></pre>\n\n<p>5.排序</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">插入排序\n    直接插入排序\n    折半插入排序\n    希尔排序(缩小增量排序)\n交换排序\n    冒泡排序\n    快速排序\t\n选择排序\n    简单选择排序\n    堆排序\n归并排序\t\t\n    两个有序序列的归并操作\n    归并排序\n基数排序\n</code></pre>\n\n<p>6.分块查找</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">分块查找 具有 索引表,存储 每块的 最大值.\n分块查找的平均查找长度是两步平均查找长度之和: ASL &#x3D; Lb + Lw ,average search length\nASL&#x3D;Lb+Lw&#x3D;(n&#x2F;s + s)&#x2F;2 + 1，可以求出当s&#x3D;n1&#x2F;2时，ASL取得最小值，且它的值为：n1&#x2F;2+1\n可以看出这个平均查找长度比直接顺序查找要好，当n&#x3D;1000时，约为33( 顺序查找 为501)\n</code></pre>\n\n\n\n<h3 id=\"分治技术\"><a href=\"#分治技术\" class=\"headerlink\" title=\"分治技术\"></a>分治技术</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">\n排序:\n\n不交换相等元素的算法更易稳定（如冒泡、插入排序）。\n交换相等元素的算法必然不稳定（如选择排序中，若存在相等元素且触发交换，则可能改变顺序）。\n\n选择排序 选择排序在每一轮中选择最小（或最大）的元素并与当前元素交换位置。这种交换可能会导致相等元素的相对顺序被打乱，因此选择排序是不稳定的。\n快速排序 快速排序通过选择一个基准元素，将数组分为两部分并递归排序。在分区过程中，基准元素与其他元素的交换可能会改变相等元素的相对顺序，因此快速排序是不稳定的。(假如 枢纽元素右侧 有两个 想等的元素 均＜枢纽元素,他们都会被交换,靠后的 被交换到前面, 靠前的 被交换到后面)\n直接插入排序:稳定,后面的元素 每次 都从后往前比,不交换 相等元素 (但 直接插入排序中的 希尔排序,不稳定)\n堆排序 堆排序通过构建堆结构来选择最大（或最小）元素并将其放置到正确位置。在调整堆的过程中，相等元素的顺序可能会被改变，因此堆排序是不稳定的。\n\n冒泡排序,是稳定的;插入排序:稳定;(从后往前比,想等元素 之间 从未进行交换)  归并排序:稳定\n----\n选择排序 不稳定;(每次从 A[i，n]中 选择 最小的元素,放到前头,如A&#x3D;[2,2_,1] 交换为:A&#x3D;[1,2_,2] ,发生了 夸元素交换,不稳定)\n快排:不稳定 ;\n\n(依据是否 进行 跨元素交换,能基本确定)\n---\n一维 最近点对问题:https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44533129&#x2F;article&#x2F;details&#x2F;103125495\n1.暴力法:O (n²) 复杂度\n2.排序O(nlogn)+线性扫描(排序后 可以在 线性时间内找到)O(n),走过排序好的表，计算每一个点到跟在它后面的点的距离，容易求出这些距离的最小值,T(n)&#x3D;O(nlogn)\n\n二维最近点对:\n二维问题中，分治法会先按 x 坐标分治，再处理跨中线的点对，此时需按 y 坐标排序并线性扫描。一维问题可视为二维问题的特例，其 “跨中线” 情况即相邻点对。\n----\n\n乘法:\n设：A和B是两个nn的矩阵，\n求：A和B的乘积C&#x3D;AB。\n求每个Ci,j：需要n次乘法，和n-1次加法，共有n2个Ci,j，则：\n复杂性： n^3次乘法，n^3-n^2次加法。\n而分治法的使用，矩阵乘法的效率没有提高。因其并未减少矩阵乘法的次数。\n矩阵乘法之STRASSEN ,基本思想：以增加加减法的次数来减少乘法次数。能 将 复杂性--&gt;需要7次乘法，和18次加法。\n\n----\n练习题:\n循环比赛 日程表[可以用分治法思想 求解]\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_44469806&#x2F;article&#x2F;details&#x2F;108936037\n</code></pre>\n\n<p><img src=\"/./%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90.assets/image-20250609175410242.png\" alt=\"image-20250609175410242\"></p>\n<h3 id=\"搜索（OPEN表-和-CLOSE表）\"><a href=\"#搜索（OPEN表-和-CLOSE表）\" class=\"headerlink\" title=\"搜索（OPEN表 和 CLOSE表）\"></a>搜索（OPEN表 和 CLOSE表）</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">对二叉搜索树的查询主要是Search、Minimum、Maximum、Successor、Predecessor等操作，这些操作都可在O(h)时间内完成，其中h是二叉树的高。即:O(logn)\n查找 Successor、Predecessor节点,也都是 在 重复 中序遍历的 一个子过程,最大不超过树深.\n-----\n二、查找后继节点（Successor）定义：中序遍历中紧跟在节点x后的节点（大于x的最小节点）。\n步骤：若x有右子树：后继为右子树的最小节点（递归左子节点至叶节点）。若x无右子树：后继为最近的左祖先节点（即向上回溯，直到找到第一个父节点y，使得x是y的左子节点）。\n时间复杂度：\\(O(h)\\)（h为树高，平衡树为\\(O(\\log n)\\)）。\n\n三、查找前驱节点（Predecessor）定义：中序遍历中位于节点x前的节点（小于x的最大节点）。\n步骤：若x有左子树：前驱为左子树的最大节点（递归右子节点至叶节点）。若x无左子树：前驱为最近的右祖先节点（即向上回溯，直到找到第一个父节点y，使得x是y的右子节点）。\n时间复杂度：\\(O(h)\\)。\n\n四、插入节点步骤：从根节点开始，比较插入值与当前节点值的大小。若插入值 &lt; 当前节点值，递归左子树；否则递归右子树，直到找到空位置。在空位置创建新节点，连接至父节点。\n时间复杂度：\\(O(h)\\)。\n\n五、删除节点步骤：若节点无子节点：直接删除。若节点有一个子节点：用子节点替换该节点。若节点有两个子节点：找到后继节点（右子树的最小节点）或前驱节点（左子树的最大节点）【任选一种，一般选用 后继节点】。用后继 &#x2F; 前驱的值替换该节点的值，然后删除后继 &#x2F; 前驱节点（递归处理可能的子节点）。\n时间复杂度：\\(O(h)\\)。\n\n----\n删除,是O(logn),涉及到 查找 后继Successor节点.让 父节点 指向 后继节点.(当然 删除后 可能会不平衡,此时 引入 AVL搜索树(平衡二叉搜索树)\nB树(平衡多路查找树))\n---------------------------------\nOPEN表用于存放未扩展节点，提供了待扩展节点，当OPEN表空且未找到目标节点时,搜索失败。\nCLOSED表用于存放已扩展节点。而CLOSED表在搜索成功时为回溯求解路径提供依据。\n针对不同的问题，OPEN表与CLOSED表可采用不同维护策略及数据结构。\n\n一.树式搜索：\n　 步1： 把初始节点So放入OPEN表中。\n　步2 ：若OPEN表为空, 则搜索失败, 退出。 \n　步3 ：移出OPEN表中第一个节点N放入CLOSED表中, 并冠以顺序编号n。\n　步4 ：若目标节点Sg&#x3D;N, 则搜索成功, 结束。 \n　步5 ：若N不可扩展, 则转步2。\n    步6 ：扩展N, 生成一组子节点, 对这组子节点做如下处理：\n  (1)删除N的先辈节点(如果有的话)。\n  (2)对已存在于OPEN表的节点(如果有的话)也删除之；但删除之前要比较其返回初始节点的新路径与原路径,如果新路径“短”, 则修改这些节点在OPEN表中的原返回指针,使其沿新路返回。\n  (3)对已存在于CLOSED表的节点(如果有的话), 做与(2)同样的处理, 并且再将其移出CLOSED表, 放入OPEN表重新扩展(为了重新计算代价)。\n  (4)对其余子节点配上指向N的返回指针后放入OPEN表中某处, 或对OPEN表进行重新排序, 转步2。\n  \n  \n   ⚠️：(2) 步6中修改返回指针的原因：节点被第二次生成, 返回初始节点的路径有两条, “长度”可能不同。 当新路短时采用新路。\n\n二.后面还有 不回溯、带回溯的 线式搜索。 广度优先，深度优先 搜索\n\n  ----\n直接跳转例子：8数码问题：\n广度优先\n深度优先\n有界深度优先搜索法（有限深度内，不一定能找到最优解；此时 可改为可变深度限制）\n\n\n8数码问题\nA算法： h(n) &#x3D; “不在位”的将牌数\nA*算法：h(n) &#x3D; 将牌“不在位”的距离和\n----\n\n一、OPEN 表与 CLOSE 表的定义\nOPEN 表：存储待扩展的节点（未访问但可能需要探索的节点）。\nCLOSE 表：存储已扩展的节点（已访问且无需再处理的节点）。\n\n深度优先搜索（DFS）\nOPEN 表：使用栈（Stack） 实现，遵循 “后进先出（LIFO）” 原则。\n新生成的子节点优先入栈，确保先探索深层节点。\nCLOSE 表：使用集合（如哈希表）记录已访问节点，避免重复扩展。\n广度优先搜索（BFS）\nOPEN 表：使用队列（Queue） 实现，遵循 “先进先出（FIFO）” 原则。\n新生成的子节点加入队列尾部，确保先探索浅层节点。\nCLOSE 表：同样用集合记录已访问节点，功能与 DFS 一致\n-----\n三、CLOSE 表的作用与实现核心作用：避免重复访问同一状态，防止无限循环（如环形路径）。优化搜索效率，减少冗余计算。实现方式：使用哈希表（Hash Table）存储节点状态，查询时间复杂度为 \\(O(1)\\)。节点状态需可哈希（如用坐标、状态向量等唯一标识）。\nhttps:&#x2F;&#x2F;www.doubao.com&#x2F;chat&#x2F;1825939490489090\n将 节点标记为 已访问：具体来说，就是 放入CLOSE表，从而避免 无限循环。当没有环时，可以不使用CLOSE表（例如：树形结构）\n\n\n八数码，是经典的有环问题，需要 CLOSE表。</code></pre>\n\n\n\n\n\n<h3 id=\"贪心-最简单-画图即可\"><a href=\"#贪心-最简单-画图即可\" class=\"headerlink\" title=\"贪心(最简单,画图即可)\"></a>贪心(最简单,画图即可)</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">贪心算法:【相对简单】\n（1）活动安排问题；\n（2）背包问题；(非0-1背包)\n（3）最优装载问题；\n（4）哈夫曼编码；\n（5）单源最短路径；\n（6）最小生成树；\n其中Prim算法,ppt讲的不好.链接讲的更好:https:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;it0cfot.html\n（7）多机调度问题。--&gt;单点突破\n\n</code></pre>\n\n\n\n<h3 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">动态规划：【大量的状态转移方程】\n1. 最优路径问题\n2. 资源配置问题\n3.复合系统工作可靠性问题\n4.生产与库存问题机器负荷分配问题--&gt;单点突破\n5. 设备更新问题\n6. 0-1背包问题\n\n随堂练习4:动态规划 （客观来说，缺少 了 随堂练习3）--》此 随堂练习，与 一致，是重点。\n\n某公司打算在3个不同的地区设置4个销售点，根据市场部门估计，在不同地区设置不同数量的销售点每月可得到的利润如下表所示。试问在各地区如何设置销售点可使每月总利润最大。(参照 工厂 机器负荷分配)</code></pre>\n\n\n\n\n\n<h3 id=\"分支限界技术\"><a href=\"#分支限界技术\" class=\"headerlink\" title=\"分支限界技术\"></a>分支限界技术</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">最大价值问题：\n    目标函数上界用于扩展节点选择(优先选择 价值大的 拓展)\n    目标函数下界用于剪枝(下界 用于剪枝,假如 下界&gt; 某些路径的上界,则 剪掉)\n最小耗费问题：\n    目标函数上界用于剪枝\n    目标函数下界用于扩展节点选择\n活动节点表（表PT）\n\n在0&#x2F;1背包问题中，为了在搜索过程中构建搜索经过的树结构，设一个表PT，记录搜索过程。\n再设计了一表ST，从PT中取出最大值节点进行扩充时，将最大值节点存储到表ST中，表PT和表ST的数据结构为：\n\n-----\n分支限界法：【搜索一章，回溯法问题的再度解决。BFS广度优先+ FIFO队列&#x2F;优先队列分支限界.PT表.在分支限界法中，每一个活结点只有一次机会成为扩展结点。 活结点一旦成为扩展结点，就一次性产生其所有儿子结点。 】\n图问题中的分支限界法:\n旅行商问题，即TSP问题（Traveling Salesman Problem）--&gt;单点突破\n多段图的最短路径问题\n0-1背包\n\n\n\n\n-----\n组合中的分支限界法：--》不讲了\n任务分配问题\n批处理作业调度问题</code></pre>\n\n\n\n\n\n<h1 id=\"2025-06-10考后总结\"><a href=\"#2025-06-10考后总结\" class=\"headerlink\" title=\"2025.06.10考后总结\"></a>2025.06.10考后总结</h1><pre class=\"line-numbers language-none\"><code class=\"language-none\">10*2（选择题10道） + 15*4 (大题4道) + 简答题20&#x3D;100分.\n大题 四道,尤其 注意 贪心 + 动规dp + 分支限界,占了60%-70%的分数.\n\n课堂总打分:平时分40,期末考试60分.期末考试只需要 33分即可及格,难怪王玮老师课上说:课程没及格的没见过,期末考试没及格的倒是有过一个女生.(学硕 算法课 某年 挂过好几个人.)\n\n选择题:\n基本可以参照:\nhttps:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_46373141&#x2F;article&#x2F;details&#x2F;135415593\n\n题型 和 覆盖知识点,较接近.\n\n需要思考的 相关知识点形如:\n归并排序算法是稳定的,何时不稳定? 答案:按照 奇偶划分时\n回溯法 是否 可拓展一个节点2次?\n\n大题:\n1.分治法: 给出 12个数 二路归并排序,每轮排序后的结果\n2.搜索 回溯法:给出 一个八数码问题(老师补充:使用BFS),基于A启发算法. 画图 表示 搜索过程 和 搜索路径\n3.贪心: &#123;事件,开始时间start,结束时间end,优先级p&#125; 希望优先级最大化 \n3.1 该问题是否可以用 基于 结束时间排序的 贪心算法求解(题目中提到 不需要证明,我怀疑是否只需要给出反例) \n3.2 假如 定义 单位时间优先级f&#x3D;p&#x2F;(end-start),此时是否 可以按照f进行贪心策略求解?如果不能,请给出求解思路\n4.动态规划: 写出 一个0-1背包问题的动态规划解法中的,状态定义 递归方程 和 递归过程\n\n简答题:\nppt上 原题:(数字都没变)\n分支限界问题,多段图 最短路径问题\n1.画图 表示 搜索过程 和 搜索路径\n2.假如 换用 更大的 up(上界,用于 剪枝),会对求解过程 和 结果 产生什么影响?\n\n\n总结：\n题型分布合理，和课上王玮老师说的一模一样。每年可能就是 变样地从ppt中 抽不同的题型，但 考察章节、题型一模一样。可能会变数字，可能不会变数字。\n难度相对较小，及格还是简单。\n</code></pre>\n\n","feature":true,"text":"这是 研一-王玮-算法与算法分析 课程的 简要复习笔记. 时间复杂度符号: T(n) 大O符号（Ο），读作”big-oh”，表示函数的上界，用于描述算法的最坏情况性能。例如，如果一个算法的时间复杂度为O(n^2)，则意味着在最坏情况下，算法的执行时间不会超过n^2的某个常数倍1。...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":1,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"},{"name":"分析","slug":"分析","count":1,"path":"api/tags/分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E4%B8%9A%E8%A6%81%E6%B1%82\"><span class=\"toc-text\">作业要求</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0\"><span class=\"toc-text\">知识复习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#overview\"><span class=\"toc-text\">overview</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%B4%E6%8E%A5%E5%81%9A%E9%A2%98%EF%BC%8C%E8%87%AA%E6%88%91%E6%B5%8B%E8%AF%84\"><span class=\"toc-text\">直接做题，自我测评</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E4%B8%80%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90\"><span class=\"toc-text\">基础一章:算法与算法分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%B2%BB%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">分治技术</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%90%9C%E7%B4%A2%EF%BC%88OPEN%E8%A1%A8-%E5%92%8C-CLOSE%E8%A1%A8%EF%BC%89\"><span class=\"toc-text\">搜索（OPEN表 和 CLOSE表）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B4%AA%E5%BF%83-%E6%9C%80%E7%AE%80%E5%8D%95-%E7%94%BB%E5%9B%BE%E5%8D%B3%E5%8F%AF\"><span class=\"toc-text\">贪心(最简单,画图即可)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">动态规划</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">分支限界技术</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2025-06-10%E8%80%83%E5%90%8E%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">2025.06.10考后总结</span></a>","author":{"name":"Songkang","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/StackChan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/tiexiaorenyu","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"动态规划","date":"2025-05-09T06:45:14.864Z","updated":"2025-05-09T06:55:54.108Z","comments":true,"path":"api/articles/动态规划.json","keywords":null,"cover":null,"text":"动规问题,包含贪心(最简单. 同样包含: 最优子结构 无后效性. 贪心 关键在于 能够证明 贪心策略能取得最优解.) 21道 LeetCode 题解带你搞懂动态规划！ ","link":"","photos":[],"count_time":{"symbolsCount":84,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Songkang","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"https://github.com/StackChan","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://blog.csdn.net/tiexiaorenyu","juejin":"","customs":{}}},"feature":true}}